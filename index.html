<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.1.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="寻门而入，破门而出。">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://Syq777.github.io/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="寻门而入，破门而出。">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description" content="寻门而入，破门而出。">





  
  
  <link rel="canonical" href="https://Syq777.github.io/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Hexo</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-首页 menu-item-active">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-标签">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-类别">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>类别</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-档案">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>档案</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://Syq777.github.io/2019/05/03/cc++基本知识点/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Syq">
      <meta itemprop="description" content="寻门而入，破门而出。">
      <meta itemprop="image" content="/images/image.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/03/cc++基本知识点/" class="post-title-link" itemprop="url">c/c++基本知识点</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-05-03 22:39:09 / 修改时间：22:47:40" itemprop="dateCreated datePublished" datetime="2019-05-03T22:39:09+08:00">2019-05-03</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/算法笔记/" itemprop="url" rel="index"><span itemprop="name">算法笔记</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="https://images-cdn.shimo.im/gzQhi2s4U3Ar8WMX/15568902559718.jpg!thumbnail" alt="img"> </p>
<p><img src="https://images-cdn.shimo.im/2WjPgU9eVEUmuUA0/15568902560921.jpg!thumbnail" alt="img"> </p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://Syq777.github.io/2019/05/01/today_04.30/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Syq">
      <meta itemprop="description" content="寻门而入，破门而出。">
      <meta itemprop="image" content="/images/image.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/01/today_04.30/" class="post-title-link" itemprop="url">today_04.30</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-05-01 09:06:11" itemprop="dateCreated datePublished" datetime="2019-05-01T09:06:11+08:00">2019-05-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-03 22:35:47" itemprop="dateModified" datetime="2019-05-03T22:35:47+08:00">2019-05-03</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/every-Day/" itemprop="url" rel="index"><span itemprop="name">every_Day</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="04-30"><a href="#04-30" class="headerlink" title="04.30"></a>04.30</h3><h5 id="知识增量："><a href="#知识增量：" class="headerlink" title="知识增量："></a>知识增量：</h5><ol>
<li>又是没有</li>
</ol>
<h5 id="今日收获："><a href="#今日收获：" class="headerlink" title="今日收获："></a>今日收获：</h5><table>
<thead>
<tr>
<th style="text-align:center">早上</th>
<th style="text-align:center">起床时间：7：00</th>
<th style="text-align:center">背单词数量：150</th>
<th style="text-align:center">到图书馆时间：3：00</th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">上午</td>
<td style="text-align:center">上课</td>
<td style="text-align:center">上课</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">中午</td>
<td style="text-align:center">睡觉</td>
<td style="text-align:center">洗澡</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">下午</td>
<td style="text-align:center">数学题</td>
<td style="text-align:center">计划</td>
<td style="text-align:center">上课</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">晚上</td>
<td style="text-align:center">6：40-7：40 English</td>
<td style="text-align:center">7：40-闭馆张宇</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">回宿舍后</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><h6 id="可以节约的时间："><a href="#可以节约的时间：" class="headerlink" title="可以节约的时间："></a>可以节约的时间：</h6><p>上课时间没有利用好</p>
<p>单词看的效果不是很好</p>
<h2 id="今日评分：3-0"><a href="#今日评分：3-0" class="headerlink" title="今日评分：3.0"></a>今日评分：3.0</h2>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://Syq777.github.io/2019/04/29/today_04.29/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Syq">
      <meta itemprop="description" content="寻门而入，破门而出。">
      <meta itemprop="image" content="/images/image.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/29/today_04.29/" class="post-title-link" itemprop="url">today_04.30</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-29 22:51:22" itemprop="dateCreated datePublished" datetime="2019-04-29T22:51:22+08:00">2019-04-29</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-01 09:05:57" itemprop="dateModified" datetime="2019-05-01T09:05:57+08:00">2019-05-01</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/every-Day/" itemprop="url" rel="index"><span itemprop="name">every_Day</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="04-30"><a href="#04-30" class="headerlink" title="04.30"></a>04.30</h3><h5 id="知识增量："><a href="#知识增量：" class="headerlink" title="知识增量："></a>知识增量：</h5><ol>
<li>又是没有</li>
</ol>
<h5 id="今日收获："><a href="#今日收获：" class="headerlink" title="今日收获："></a>今日收获：</h5><table>
<thead>
<tr>
<th style="text-align:center">早上</th>
<th style="text-align:center">起床时间：7：00</th>
<th style="text-align:center">背单词数量：150</th>
<th style="text-align:center">到图书馆时间：3：00</th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">上午</td>
<td style="text-align:center">上课</td>
<td style="text-align:center">上课</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">中午</td>
<td style="text-align:center">睡觉</td>
<td style="text-align:center">洗澡</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">下午</td>
<td style="text-align:center">数学题</td>
<td style="text-align:center">计划</td>
<td style="text-align:center">上课</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">晚上</td>
<td style="text-align:center">6：40-7：40 English</td>
<td style="text-align:center">7：40-闭馆张宇</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">回宿舍后</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><h6 id="可以节约的时间："><a href="#可以节约的时间：" class="headerlink" title="可以节约的时间："></a>可以节约的时间：</h6><p>上课时间没有利用好</p>
<p>单词看的效果不是很好</p>
<h2 id="今日评分：3-0"><a href="#今日评分：3-0" class="headerlink" title="今日评分：3.0"></a>今日评分：3.0</h2>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://Syq777.github.io/2019/04/29/template/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Syq">
      <meta itemprop="description" content="寻门而入，破门而出。">
      <meta itemprop="image" content="/images/image.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/29/template/" class="post-title-link" itemprop="url">template</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-29 00:22:09" itemprop="dateCreated datePublished" datetime="2019-04-29T00:22:09+08:00">2019-04-29</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-25 21:40:35" itemprop="dateModified" datetime="2019-04-25T21:40:35+08:00">2019-04-25</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/template/" itemprop="url" rel="index"><span itemprop="name">template</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://Syq777.github.io/2019/04/29/框架知识点/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Syq">
      <meta itemprop="description" content="寻门而入，破门而出。">
      <meta itemprop="image" content="/images/image.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/29/框架知识点/" class="post-title-link" itemprop="url">框架知识点</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-29 00:19:06 / 修改时间：00:24:33" itemprop="dateCreated datePublished" datetime="2019-04-29T00:19:06+08:00">2019-04-29</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/框架/" itemprop="url" rel="index"><span itemprop="name">框架</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h6 id="框架知识点"><a href="#框架知识点" class="headerlink" title="框架知识点"></a>框架知识点</h6><ol>
<li><p>运用Struts2框架启动tomcat服务显示异常 原因：My<strong>eclipse发布项目的时候并未自动将引用的jar包copy到WEB-INF/目录下，导致编译器找不到所使用的class.</strong><br>需要选中项目,右键选择Properties-&gt;Myeclispe-&gt;Deployment Assembly-&gt;Add以此来自动添加</p>
</li>
<li><p>使用form表单是一定要写上每一个输入框的name属性，不然无法传值，导致不猛登录成功</p>
</li>
<li><p>HttpSession session=request.getSession();是使用session存储值得标配，必须在每一个方法中写上该语句</p>
</li>
<li><p>使用Struts2的验证框架时，必须在struts.xml配置文件中编写result</p>
</li>
<li><result name="”input”">指向目标文件的路径</result>
</li>
<li><p>（1）设计业务逻辑接口、<br>（2）设计业务逻辑接口实现类<br>（3）设计Action类<br>（4）页面调用</p>
</li>
<li><p>超链接也可以连接action</p>
</li>
<li><p>jsp连接到用一文件夹下的其他jsp页面是，文件夹左面不用写“/”;<br>例如:students/Students_add.jsp</p>
</li>
<li><p>spring cloud是建立在spring boot之上</p>
</li>
</ol>
<h6 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h6><ol>
<li>spring （管理工具）</li>
</ol>
<p>IOC(控制反转) 应用程序本身不负责依赖对象德创建和维护，而是由外部容器负责创建和维护<br>通过DI(依赖注入)使应用程序运用逻辑</p>
<p>AOP（面向切面）<br>  面向切面：分离应用的业务逻辑与系统级服务<br>在某种意义上讲是一种容器<br>接口是对内部功能给外界的说明，但是内部如何实现则是保密的<br>面向接口编程  接口名 a=new 接口的实现类<br>Spring bean的配置<br>Bean的配置项Id<br>Class<br>Scpoe</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://Syq777.github.io/2019/04/29/maven框架/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Syq">
      <meta itemprop="description" content="寻门而入，破门而出。">
      <meta itemprop="image" content="/images/image.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/29/maven框架/" class="post-title-link" itemprop="url">maven框架结构</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-29 00:18:44" itemprop="dateCreated datePublished" datetime="2019-04-29T00:18:44+08:00">2019-04-29</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-28 23:53:11" itemprop="dateModified" datetime="2019-04-28T23:53:11+08:00">2019-04-28</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/maven/" itemprop="url" rel="index"><span itemprop="name">maven</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h6 id="maven框架结构"><a href="#maven框架结构" class="headerlink" title="maven框架结构"></a>maven框架结构</h6><p>src<br>   -main<br>        -java<br>               -package<br>   -test<br>        -java<br>              -package<br>    resources</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://Syq777.github.io/2019/04/29/开始屏幕的磁贴一重启就自动还原,求助! - Microsoft Community/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Syq">
      <meta itemprop="description" content="寻门而入，破门而出。">
      <meta itemprop="image" content="/images/image.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/29/开始屏幕的磁贴一重启就自动还原,求助! - Microsoft Community/" class="post-title-link" itemprop="url">开始屏幕的磁贴重启后自动还原</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-29 00:06:26" itemprop="dateCreated datePublished" datetime="2019-04-29T00:06:26+08:00">2019-04-29</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/WIn10/" itemprop="url" rel="index"><span itemprop="name">WIn10</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>您好，</p>
<h6 id="开始屏幕的磁贴重启后自动还原"><a href="#开始屏幕的磁贴重启后自动还原" class="headerlink" title="开始屏幕的磁贴重启后自动还原"></a>开始屏幕的磁贴重启后自动还原</h6><p>了解到您在使用时遇到问题。</p>
<p>我们在测试时，开始磁贴能够正常保存且在该路径下并没有发现您说的文件。</p>
<p>请您尝试使用Dism命令修复下系统。</p>
<p>在小娜中搜索命令提示符，右击以管理员身份运行命令提示符，输入以下命令</p>
<p>扫描映像是否完整：</p>
<p>DISM.exe /Online /Cleanup-image /Scanhealth</p>
<p>完成后再检测映像：</p>
<p>DISM.exe /Online /Cleanup-image /Checkhealth</p>
<p>然后再修复映像：</p>
<p>DISM.exe /Online /Cleanup-image /Restorehealth</p>
<p>最后检查系统并修复：</p>
<p>sfc /scannow</p>
<p>如果问题依旧，请新建一个本地管理员账户，在新建的账户中查看问题是否存在。</p>
<p>在小娜中搜索命令提示符，右击以管理员运行命令提示符，粘贴输入下面两行指令新建一个管理员本地账户：</p>
<p>net user User 789456 /add      （User是新建账户名，789456是新建密码，名称和密码根据需要都可以修改）</p>
<p>net localgroup administrators User /add    （为该账户添加管理员权限）</p>
<p>希望以上信息能够帮助到您。</p>
<p>如果您所咨询的问题，得到解决请对我们的回复进行标记解答（对我们的工作非常重要）</p>
<p>如您的问题没有解决，我们会继续为您提供技术支持。</p>
<p>我们秉承客户至上的服务理念。如果您对微软工程师在论坛中的服务有意见与建议，欢迎提出，以便我们提供更优质的服务。Microsoft Answers欢迎您！</p>
<p>此回复已帮助 1 个人</p>
<p>·</p>
<p>这是否解决了你的问题?</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://Syq777.github.io/2019/04/29/java面试/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Syq">
      <meta itemprop="description" content="寻门而入，破门而出。">
      <meta itemprop="image" content="/images/image.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/29/java面试/" class="post-title-link" itemprop="url">Java面试题集及参考答案</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-29 00:04:47 / 修改时间：00:26:01" itemprop="dateCreated datePublished" datetime="2019-04-29T00:04:47+08:00">2019-04-29</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h6 id="超级全面的Java面试题集及参考答案"><a href="#超级全面的Java面试题集及参考答案" class="headerlink" title="超级全面的Java面试题集及参考答案"></a>超级全面的Java面试题集及参考答案</h6><p><a href="https://blog.csdn.net/dd864140130/article/details/55833087" target="_blank" rel="noopener">https://blog.csdn.net/dd864140130/article/details/55833087</a></p>
<p>今天要谈的主题是关于求职.求职是在每个技术人员的生涯中都要经历多次,对于我们大部分人而言,在进入自己心仪的公司之前少不了准备工作,有一份全面细致面试题将帮助我们减少许多麻烦.在跳槽季来临之前,特地做这个系列的文章,一方面帮助自己巩固下基础,另一方面也希望帮助想要换工作的朋友.</p>
<p><strong>相关概念</strong><br><strong>面向对象的三个特征</strong><br>封装,继承,多态.这个应该是人人皆知.有时候也会加上抽象.<br><strong>多态的好处</strong><br>允许不同类对象对同一消息做出响应,即同一消息可以根据发送对象的不同而采用多种不同的行为方式(发送消息就是函数调用).主要有以下优点:</p>
<ol>
<li>可替换性:多态对已存在代码具有可替换性.</li>
<li>可扩充性:增加新的子类不影响已经存在的类结构.</li>
<li>接口性:多态是超类通过方法签名,向子类提供一个公共接口,由子类来完善或者重写它来实现的.</li>
<li>灵活性.</li>
<li>简化性.<br><strong>代码中如何实现多态</strong><br>实现多态主要有以下三种方式: </li>
<li><p>接口实现 </p>
</li>
<li><p>继承父类重写方法 </p>
</li>
<li><p>同一类中进行方法重载</p>
</li>
</ol>
<p><strong>虚拟机是如何实现多态的</strong><br>动态绑定技术(dynamic binding),执行期间判断所引用对象的实际类型,根据实际类型调用对应的方法.<br><strong>接口的意义</strong><br>接口的意义用三个词就可以概括:规范,扩展,回调.<br><strong>抽象类的意义</strong><br>抽象类的意义可以用三句话来概括:</p>
<ol>
<li>为其他子类提供一个公共的类型</li>
<li>封装子类中重复定义的内容</li>
<li>定义抽象方法,子类虽然有不同的实现,但是定义时一致的<br><strong>接口和抽象类的区别</strong></li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>比较</strong></th>
<th style="text-align:left"><strong>抽象类</strong></th>
<th style="text-align:left"><strong>接口</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">默认方法</td>
<td style="text-align:left">抽象类可以有默认的方法实现</td>
<td style="text-align:left">java 8之前,接口中不存在方法的实现.</td>
</tr>
<tr>
<td style="text-align:left">实现方式</td>
<td style="text-align:left">子类使用extends关键字来继承抽象类.如果子类不是抽象类,子类需要提供抽象类中所声明方法的实现.</td>
<td style="text-align:left">子类使用implements来实现接口,需要提供接口中所有声明的实现.</td>
</tr>
<tr>
<td style="text-align:left">构造器</td>
<td style="text-align:left">抽象类中可以有构造器,</td>
<td style="text-align:left">接口中不能</td>
</tr>
<tr>
<td style="text-align:left">和正常类区别</td>
<td style="text-align:left">抽象类不能被实例化</td>
<td style="text-align:left">接口则是完全不同的类型</td>
</tr>
<tr>
<td style="text-align:left">访问修饰符</td>
<td style="text-align:left">抽象方法可以有public,protected和default等修饰</td>
<td style="text-align:left">接口默认是public,不能使用其他修饰符</td>
</tr>
<tr>
<td style="text-align:left">多继承</td>
<td style="text-align:left">一个子类只能存在一个父类</td>
<td style="text-align:left">一个子类可以存在多个接口</td>
</tr>
<tr>
<td style="text-align:left">添加新方法</td>
<td style="text-align:left">想抽象类中添加新方法,可以提供默认的实现,因此可以不修改子类现有的代码</td>
<td style="text-align:left">如果往接口中添加新方法,则子类中需要实现该方法.</td>
</tr>
</tbody>
</table>
<p><strong>父类的静态方法能否被子类重写</strong><br>不能.重写只适用于实例方法,不能用于静态方法,而子类当中含有和父类相同签名的静态方法,我们一般称之为隐藏.<br><strong>什么是不可变对象</strong><br>不可变对象指对象一旦被创建，状态就不能再改变。任何修改都会创建一个新的对象，如 String、Integer及其它包装类。<br><strong>静态变量和实例变量的区别?</strong><br>静态变量存储在方法区,属于类所有.实例变量存储在堆当中,其引用存在当前线程栈.<br><strong>能否创建一个包含可变对象的不可变对象?</strong><br>当然可以创建一个包含可变对象的不可变对象的，你只需要谨慎一点，不要共享可变对象的引用就可以了，如果需要变化时，就返回原对象的一个拷贝。最常见的例子就是对象中包含一个日期对象的引用.<br><strong>java 创建对象的几种方式</strong></p>
<ol>
<li>采用new</li>
<li>通过反射</li>
<li>采用clone</li>
<li>通过序列化机制<br>前2者都需要显式地调用构造方法. 造成耦合性最高的恰好是第一种,因此你发现无论什么框架,只要涉及到解耦必先减少new的使用.<br><strong>switch中能否使用string做参数</strong><br>在idk 1.7之前,switch只能支持byte,short,char,int或者其对应的封装类以及Enum类型。从idk 1.7之后switch开始支持String.<br><strong>switch能否作用在byte,long上?</strong><br>可以用在byte上,但是不能用在long上.<br><strong>String s1=”ab”,String s2=”a”+”b”,String s3=”a”,String s4=”b”,s5=s3+s4请问s5==s2返回什么?</strong><br>返回false.在编译过程中,编译器会将s2直接优化为”ab”,会将其放置在常量池当中,s5则是被创建在堆区,相当于s5=new String(“ab”);<br><strong>你对String对象的intern()熟悉么?</strong><br>intern()方法会首先从常量池中查找是否存在该常量值,如果常量池中不存在则现在常量池中创建,如果已经存在则直接返回.<br>比如<br>String s1=”aa”;<br>String s2=s1.intern();<br>System.out.print(s1==s2);//返回true<br><strong>Object中有哪些公共方法?</strong></li>
<li>equals()</li>
<li>clone()</li>
<li>getClass()</li>
<li>notify(),notifyAll(),wait()</li>
<li>toString<br><strong>java当中的四种引用</strong><br>强引用,软引用,弱引用,虚引用.不同的引用类型主要体现在GC上:</li>
<li>强引用：如果一个对象具有强引用，它就不会被垃圾回收器回收。即使当前内存空间不足，JVM也不会回收它，而是抛出 OutOfMemoryError 错误，使程序异常终止。如果想中断强引用和某个对象之间的关联，可以显式地将引用赋值为null，这样一来的话，JVM在合适的时间就会回收该对象</li>
<li>软引用：在使用软引用时，如果内存的空间足够，软引用就能继续被使用，而不会被垃圾回收器回收，只有在内存不足时，软引用才会被垃圾回收器回收。</li>
<li>弱引用：具有弱引用的对象拥有的生命周期更短暂。因为当 JVM 进行垃圾回收，一旦发现弱引用对象，无论当前内存空间是否充足，都会将弱引用回收。不过由于垃圾回收器是一个优先级较低的线程，所以并不一定能迅速发现弱引用对象</li>
<li>虚引用：顾名思义，就是形同虚设，如果一个对象仅持有虚引用，那么它相当于没有引用，在任何时候都可能被垃圾回收器回收。</li>
</ol>
<p>更多了解参见深入对象引用：<br><a href="http://blog.csdn.net/dd864140130/article/details/49885811" target="_blank" rel="noopener">http://blog.csdn.net/dd864140130/article/details/49885811</a><br><strong>WeakReference与SoftReference的区别?</strong><br>这点在四种引用类型中已经做了解释,这里简单说明一下即可:<br>虽然 WeakReference 与 SoftReference 都有利于提高 GC 和 内存的效率，但是 WeakReference ，一旦失去最后一个强引用，就会被 GC 回收，而软引用虽然不能阻止被回收，但是可以延迟到 JVM 内存不足的时候。<br><strong>为什么要有不同的引用类型</strong><br>不像C语言,我们可以控制内存的申请和释放,在Java中有时候我们需要适当的控制对象被回收的时机,因此就诞生了不同的引用类型,可以说不同的引用类型实则是对GC回收时机不可控的妥协.有以下几个使用场景可以充分的说明:</p>
<ol>
<li>利用软引用和弱引用解决OOM问题：用一个HashMap来保存图片的路径和相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片对象所占用的空间，从而有效地避免了OOM的问题.</li>
<li><p>通过软引用实现Java对象的高速缓存:比如我们创建了一Person的类，如果每次需要查询一个人的信息,哪怕是几秒中之前刚刚查询过的，都要重新构建一个实例，这将引起大量Person对象的消耗,并且由于这些对象的生命周期相对较短,会引起多次GC影响性能。此时,通过软引用和 HashMap 的结合可以构建高速缓存,提供性能.<br><strong>java中==和**</strong>eqauls()<strong><strong>的区别,</strong></strong>equals()<strong>**和`hashcode的区别</strong><br>==是运算符,用于比较两个变量是否相等,而equals是Object类的方法,用于比较两个对象是否相等.默认Object类的equals方法是比较两个对象的地址,此时和==的结果一样.换句话说:基本类型比较用==,比较的是他们的值.默认下,对象用==比较时,比较的是内存地址,如果需要比较对象内容,需要重写equal方法<br><strong>equals()**</strong>和<strong><strong>hashcode()</strong></strong>的联系<strong><br>hashCode()是Object类的一个方法,返回一个哈希值.如果两个对象根据equal()方法比较相等,那么调用这两个对象中任意一个对象的hashCode()方法必须产生相同的哈希值.<br>如果两个对象根据eqaul()方法比较不相等,那么产生的哈希值不一定相等(碰撞的情况下还是会相等的.)
</strong>a.hashCode()有什么用?与a.equals(b)有什么关系<strong><br>hashCode() 方法是相应对象整型的 hash 值。它常用于基于 hash 的集合类，如 Hashtable、HashMap、LinkedHashMap等等。它与 equals() 方法关系特别紧密。根据 Java 规范，使用 equal() 方法来判断两个相等的对象，必须具有相同的 hashcode。<br>将对象放入到集合中时,首先判断要放入对象的hashcode是否已经在集合中存在,不存在则直接放入集合.如果hashcode相等,然后通过equal()方法判断要放入对象与集合中的任意对象是否相等:如果equal()判断不相等,直接将该元素放入集合中,否则不放入.
</strong>有没有可能两个不相等的对象有相同的hashcode<strong><br>有可能，两个不相等的对象可能会有相同的 hashcode 值，这就是为什么在 hashmap 中会有冲突。如果两个对象相等，必须有相同的hashcode 值，反之不成立.
</strong>可以在hashcode中使用随机数字吗?<strong><br>不行，因为同一对象的 hashcode 值必须是相同的
</strong>a==b与a.equals(b)有什么区别<strong><br>如果a 和b 都是对象，则 a==b 是比较两个对象的引用，只有当 a 和 b 指向的是堆中的同一个对象才会返回 true，而 a.equals(b) 是进行逻辑比较，所以通常需要重写该方法来提供逻辑一致性的比较。例如，String 类重写 equals() 方法，所以可以用于两个不同对象，但是包含的字母相同的比较。
</strong>3*0.1==0.3<strong>**返回值是什么</strong><br>false，因为有些浮点数不能完全精确的表示出来。<br><strong>a=a+b与a+=b有什么区别吗?</strong><br>+=操作符会进行隐式自动类型转换,此处a+=b隐式的将加操作的结果类型强制转换为持有结果的类型,而a=a+b则不会自动进行类型转换.如：<br>byte a = 127;<br>byte b = 127;<br>b = a + b; // error : cannot convert from int to byte<br>b += a; // ok<br>（译者注：这个地方应该表述的有误，其实无论 a+b 的值为多少，编译器都会报错，因为 a+b 操作会将 a、b 提升为 int 类型，所以将 int 类型赋值给 byte 就会编译出错）<br><strong>short s1= 1; s1 = s1 + 1; 该段代码是否有错,有的话怎么改？</strong><br>有错误,short类型在进行运算时会自动提升为int类型,也就是说s1+1的运算结果是int类型.<br><strong>short s1= 1; s1 += 1; 该段代码是否有错,有的话怎么改？</strong><br>+=操作符会自动对右边的表达式结果强转匹配左边的数据类型,所以没错.<br><strong>&amp; 和 &amp;&amp;的区别</strong><br>首先记住&amp;是位操作,而&amp;&amp;是逻辑运算符.另外需要记住逻辑运算符具有短路特性,而&amp;不具备短路特性.<br>public class Test{<br>static String name;</p>
<p>public static void main(String[] args){</p>
<pre><code>if(name!=null&amp;userName.equals(&quot;&quot;)){
    System.out.println(&quot;ok&quot;);
}else{
    System.out.println(&quot;erro&quot;);
}
</code></pre><p>}<br>}</p>
</li>
</ol>
<p>以上代码将会抛出空指针异常.<br><strong>一个.java文件内部可以有类?(非内部类)</strong><br>只能有一个public公共类,但是可以有多个default修饰的类.<br><strong>如何正确的退出多层嵌套循环.</strong></p>
<ol>
<li>使用标号和break;</li>
<li>通过在外层循环中添加标识符<br><strong>内部类的作用</strong><br>内部类可以有多个实例,每个实例都有自己的状态信息,并且与其他外围对象的信息相互独立.在单个外围类当中,可以让多个内部类以不同的方式实现同一接口,或者继承同一个类.创建内部类对象的时刻不依赖于外部类对象的创建.内部类并没有令人疑惑的”is-a”关系,它就像是一个独立的实体.<br>内部类提供了更好的封装,除了该外围类,其他类都不能访问<br><strong>final,finalize和finally的不同之处</strong><br>final 是一个修饰符，可以修饰变量、方法和类。如果 final 修饰变量，意味着该变量的值在初始化后不能被改变。finalize 方法是在对象被回收之前调用的方法，给对象自己最后一个复活的机会，但是什么时候调用 finalize 没有保证。finally 是一个关键字，与 try 和 catch 一起用于异常的处理。finally 块一定会被执行，无论在 try 块中是否有发生异常。<br><strong>clone()是哪个类的方法?</strong><br>java.lang.Cloneable 是一个标示性接口，不包含任何方法，clone 方法在 object 类中定义。并且需要知道 clone() 方法是一个本地方法，这意味着它是由 c 或 c++ 或 其他本地语言实现的。<br><strong>深拷贝和浅拷贝的区别是什么?</strong><br>浅拷贝：被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。换言之，浅拷贝仅仅复制所考虑的对象，而不复制它所引用的对象。<br>深拷贝：被复制对象的所有变量都含有与原来的对象相同的值，而那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。换言之，深拷贝把要复制的对象所引用的对象都复制了一遍。<br><strong>static都有哪些用法?</strong><br>几乎所有的人都知道static关键字这两个基本的用法:静态变量和静态方法.也就是被static所修饰的变量/方法都属于类的静态资源,类实例所共享.<br>除了静态变量和静态方法之外,static也用于静态块,多用于初始化操作:<br>public calss PreCache{<br>static{<pre><code>*//执行相关操作*
</code></pre>}<br>}</li>
</ol>
<p>此外static也多用于修饰内部类,此时称之为静态内部类.<br>最后一种用法就是静态导包,即import static.import static是在JDK 1.5之后引入的新特性,可以用来指定导入某个类中的静态资源,并且不需要使用类名.资源名,可以直接使用资源名,比如:<br>import static java.lang.Math.*;</p>
<p>public class Test{</p>
<p>   public static void main(String[] args){<br>       <em>//System.out.println(Math.sin(20));传统做法</em><br>       System.out.println(sin(20));<br>   }<br>}</p>
<p><strong>final有哪些用法</strong><br>final也是很多面试喜欢问的地方,能回答下以下三点就不错了:<br>1.被final修饰的类不可以被继承<br>2.被final修饰的方法不可以被重写<br>3.被final修饰的变量不可以被改变.如果修饰引用,那么表示引用不可变,引用指向的内容可变.<br>4.被final修饰的方法,JVM会尝试将其内联,以提高运行效率<br>5.被final修饰的常量,在编译阶段会存入常量池中.<br>回答出编译器对final域要遵守的两个重排序规则更好:<br>1.在构造函数内对一个final域的写入,与随后把这个被构造对象的引用赋值给一个引用变量,这两个操作之间不能重排序.<br>2.初次读一个包含final域的对象的引用,与随后初次读这个final域,这两个操作之间不能重排序.</p>
<p><strong>数据类型相关</strong><br><strong>java中int char,long各占多少字节?</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>类型</strong></th>
<th style="text-align:left"><strong>位数</strong></th>
<th style="text-align:left"><strong>字节数</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">short</td>
<td style="text-align:left">2</td>
<td style="text-align:left">16</td>
</tr>
<tr>
<td style="text-align:left">int</td>
<td style="text-align:left">4</td>
<td style="text-align:left">32</td>
</tr>
<tr>
<td style="text-align:left">long</td>
<td style="text-align:left">8</td>
<td style="text-align:left">64</td>
</tr>
<tr>
<td style="text-align:left">float</td>
<td style="text-align:left">4</td>
<td style="text-align:left">32</td>
</tr>
<tr>
<td style="text-align:left">double</td>
<td style="text-align:left">8</td>
<td style="text-align:left">64</td>
</tr>
<tr>
<td style="text-align:left">char</td>
<td style="text-align:left">2</td>
<td style="text-align:left">16</td>
</tr>
</tbody>
</table>
<p><strong>64位的JVM当中,int的长度是多少?</strong><br>Java 中，int 类型变量的长度是一个固定值，与平台无关，都是 32 位。意思就是说，在 32 位 和 64 位 的Java 虚拟机中，int 类型的长度是相同的。<br><strong>int和Integer的区别</strong><br>Integer是int的包装类型,在拆箱和装箱中,二者自动转换.int是基本类型，直接存数值，而integer是对象，用一个引用指向这个对象.<br><strong>int 和Integer谁占用的内存更多?</strong><br>Integer 对象会占用更多的内存。Integer是一个对象，需要存储对象的元数据。但是 int 是一个原始类型的数据，所以占用的空间更少。<br><strong>String,StringBuffer和StringBuilder区别</strong><br>String是字符串常量,final修饰;StringBuffer字符串变量(线程安全);<br>StringBuilder 字符串变量(线程不安全).<br><strong>String和StringBuffer</strong><br>String和StringBuffer主要区别是性能:String是不可变对象,每次对String类型进行操作都等同于产生了一个新的String对象,然后指向新的String对象.所以尽量不在对String进行大量的拼接操作,否则会产生很多临时对象,导致GC开始工作,影响系统性能.<br>StringBuffer是对对象本身操作,而不是产生新的对象,因此在有大量拼接的情况下,我们建议使用StringBuffer.<br>但是需要注意现在JVM会对String拼接做一定的优化:<br>String s=“This is only ”+”simple”+”test”会被虚拟机直接优化成String s=“This is only simple test”,此时就不存在拼接过程.<br><strong>StringBuffer和StringBuilder</strong><br>StringBuffer是线程安全的可变字符串,其内部实现是可变数组.StringBuilder是jdk 1.5新增的,其功能和StringBuffer类似,但是非线程安全.因此,在没有多线程问题的前提下,使用StringBuilder会取得更好的性能.<br><strong>什么是编译器常量?使用它有什么风险?</strong><br>公共静态不可变（public static final ）变量也就是我们所说的编译期常量，这里的 public 可选的。实际上这些变量在编译时会被替换掉，因为编译器知道这些变量的值，并且知道这些变量在运行时不能改变。这种方式存在的一个问题是你使用了一个内部的或第三方库中的公有编译时常量，但是这个值后面被其他人改变了，但是你的客户端仍然在使用老的值，甚至你已经部署了一个新的jar。为了避免这种情况，当你在更新依赖 JAR 文件时，确保重新编译你的程序。<br><strong>java当中使用什么类型表示价格比较好?</strong><br>如果不是特别关心内存和性能的话，使用BigDecimal，否则使用预定义精度的 double 类型。<br><strong>如何将byte转为String</strong><br>可以使用 String 接收 byte[] 参数的构造器来进行转换，需要注意的点是要使用的正确的编码，否则会使用平台默认编码，这个编码可能跟原来的编码相同，也可能不同。<br><strong>可以将int强转为byte类型么?会产生什么问题?</strong><br>我们可以做强制转换，但是Java中int是32位的而byte是8 位的，所以,如果强制转化int类型的高24位将会被丢弃，byte 类型的范围是从-128到128</p>
<p><strong>关于垃圾回收</strong><br><strong>你知道哪些垃圾回收算法?</strong><br>垃圾回收从理论上非常容易理解,具体的方法有以下几种: </p>
<ol>
<li><p>标记-清除 </p>
</li>
<li><p>标记-复制 </p>
</li>
<li><p>标记-整理 </p>
</li>
<li><p>分代回收 </p>
</li>
</ol>
<p>更详细的内容参见深入理解垃圾回收算法：<br><a href="http://blog.csdn.net/dd864140130/article/details/50084471" target="_blank" rel="noopener">http://blog.csdn.net/dd864140130/article/details/50084471</a><br><strong>如何判断一个对象是否应该被回收</strong><br>这就是所谓的对象存活性判断,常用的方法有两种:1.引用计数法;2:对象可达性分析.由于引用计数法存在互相引用导致无法进行GC的问题,所以目前JVM虚拟机多使用对象可达性分析算法.<br><strong>简单的解释一下垃圾回收</strong><br>Java 垃圾回收机制最基本的做法是分代回收。内存中的区域被划分成不同的世代，对象根据其存活的时间被保存在对应世代的区域中。一般的实现是划分成3个世代：年轻、年老和永久。内存的分配是发生在年轻世代中的。当一个对象存活时间足够长的时候，它就会被复制到年老世代中。对于不同的世代可以使用不同的垃圾回收算法。进行世代划分的出发点是对应用中对象存活时间进行研究之后得出的统计规律。一般来说，一个应用中的大部分对象的存活时间都很短。比如局部变量的存活时间就只在方法的执行过程中。基于这一点，对于年轻世代的垃圾回收算法就可以很有针对性.<br><strong>调用System.gc()会发生什么?</strong><br>通知GC开始工作,但是GC真正开始的时间不确定.</p>
<p><strong>进程,线程相关</strong><br><strong>说说进程,线程,协程之间的区别</strong><br>简而言之,进程是程序运行和资源分配的基本单位,一个程序至少有一个进程,一个进程至少有一个线程.进程在执行过程中拥有独立的内存单元,而多个线程共享内存资源,减少切换次数,从而效率更高.线程是进程的一个实体,是cpu调度和分派的基本单位,是比程序更小的能独立运行的基本单位.同一进程中的多个线程之间可以并发执行.<br><strong>你了解守护线程吗?它和非守护线程有什么区别</strong><br>程序运行完毕,jvm会等待非守护线程完成后关闭,但是jvm不会等待守护线程.守护线程最典型的例子就是GC线程<br><strong>什么是多线程上下文切换</strong><br>多线程的上下文切换是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。<br><strong>创建两种线程的方式?他们有什么区别?</strong><br>通过实现java.lang.Runnable或者通过扩展java.lang.Thread类.相比扩展Thread,实现Runnable接口可能更优.原因有二:</p>
<ol>
<li>Java不支持多继承.因此扩展Thread类就代表这个子类不能扩展其他类.而实现Runnable接口的类还可能扩展另一个类.</li>
<li>类可能只要求可执行即可,因此继承整个Thread类的开销过大.<br><strong>Thread类中的start()和run()方法有什么区别?</strong><br>start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程。<br><strong>怎么检测一个线程是否持有对象监视器</strong><br>Thread类提供了一个holdsLock(Object obj)方法，当且仅当对象obj的监视器被某条线程持有的时候才会返回true，注意这是一个static方法，这意味着”某条线程”指的是当前线程。<br><strong>Runnable和Callable的区别</strong><br>Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。<br>这其实是很有用的一个特性，因为多线程相比单线程更难、更复杂的一个重要原因就是因为多线程充满着未知性，某条线程是否执行了？某条线程执行了多久？某条线程执行的时候我们期望的数据是否已经赋值完毕？无法得知，我们能做的只是等待这条多线程的任务执行完毕而已。而Callable+Future/FutureTask却可以方便获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务<br><strong>什么导致线程阻塞</strong><br>阻塞指的是暂停一个线程的执行以等待某个条件发生（如某资源就绪），学过操作系统的同学对它一定已经很熟悉了。Java 提供了大量方法来支持阻塞，下面让我们逐一分析。</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>方法</strong></th>
<th style="text-align:left"><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">sleep()</td>
<td style="text-align:left">sleep() 允许 指定以毫秒为单位的一段时间作为参数，它使得线程在指定的时间内进入阻塞状态，不能得到CPU 时间，指定的时间一过，线程重新进入可执行状态。 典型地，sleep() 被用在等待某个资源就绪的情形：测试发现条件不满足后，让线程阻塞一段时间后重新测试，直到条件满足为止</td>
</tr>
<tr>
<td style="text-align:left">suspend() 和 resume()</td>
<td style="text-align:left">两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的resume() 被调用，才能使得线程重新进入可执行状态。典型地，suspend() 和 resume() 被用在等待另一个线程产生的结果的情形：测试发现结果还没有产生后，让线程阻塞，另一个线程产生了结果后，调用 resume() 使其恢复。</td>
</tr>
<tr>
<td style="text-align:left">yield()</td>
<td style="text-align:left">yield() 使当前线程放弃当前已经分得的CPU 时间，但不使当前线程阻塞，即线程仍处于可执行状态，随时可能再次分得 CPU 时间。调用 yield() 的效果等价于调度程序认为该线程已执行了足够的时间从而转到另一个线程</td>
</tr>
<tr>
<td style="text-align:left">wait() 和 notify()</td>
<td style="text-align:left">两个方法配套使用，wait() 使得线程进入阻塞状态，它有两种形式，一种允许 指定以毫秒为单位的一段时间作为参数，另一种没有参数，前者当对应的 notify() 被调用或者超出指定时间时线程重新进入可执行状态，后者则必须对应的 notify() 被调用.</td>
</tr>
</tbody>
</table>
<p><strong>wait(),notify()和suspend(),resume()之间的区别</strong><br>初看起来它们与 suspend() 和 resume() 方法对没有什么分别，但是事实上它们是截然不同的。区别的核心在于，前面叙述的所有方法，阻塞时都不会释放占用的锁（如果占用了的话），而这一对方法则相反。上述的核心区别导致了一系列的细节上的区别。<br>首先，前面叙述的所有方法都隶属于 Thread 类，但是这一对却直接隶属于 Object 类，也就是说，所有对象都拥有这一对方法。初看起来这十分不可思议，但是实际上却是很自然的，因为这一对方法阻塞时要释放占用的锁，而锁是任何对象都具有的，调用任意对象的 wait() 方法导致线程阻塞，并且该对象上的锁被释放。而调用 任意对象的notify()方法则导致从调用该对象的 wait() 方法而阻塞的线程中随机选择的一个解除阻塞（但要等到获得锁后才真正可执行）。<br>其次，前面叙述的所有方法都可在任何位置调用，但是这一对方法却必须在 synchronized 方法或块中调用，理由也很简单，只有在synchronized 方法或块中当前线程才占有锁，才有锁可以释放。同样的道理，调用这一对方法的对象上的锁必须为当前线程所拥有，这样才有锁可以释放。因此，这一对方法调用必须放置在这样的 synchronized 方法或块中，该方法或块的上锁对象就是调用这一对方法的对象。若不满足这一条件，则程序虽然仍能编译，但在运行时会出现IllegalMonitorStateException 异常。<br>wait() 和 notify() 方法的上述特性决定了它们经常和synchronized关键字一起使用，将它们和操作系统进程间通信机制作一个比较就会发现它们的相似性：synchronized方法或块提供了类似于操作系统原语的功能，它们的执行不会受到多线程机制的干扰，而这一对方法则相当于 block 和wakeup 原语（这一对方法均声明为 synchronized）。它们的结合使得我们可以实现操作系统上一系列精妙的进程间通信的算法（如信号量算法），并用于解决各种复杂的线程间通信问题。<br>关于 wait() 和 notify() 方法最后再说明两点：<br>第一：调用 notify() 方法导致解除阻塞的线程是从因调用该对象的 wait() 方法而阻塞的线程中随机选取的，我们无法预料哪一个线程将会被选择，所以编程时要特别小心，避免因这种不确定性而产生问题。<br>第二：除了 notify()，还有一个方法 notifyAll() 也可起到类似作用，唯一的区别在于，调用 notifyAll() 方法将把因调用该对象的 wait() 方法而阻塞的所有线程一次性全部解除阻塞。当然，只有获得锁的那一个线程才能进入可执行状态。<br>谈到阻塞，就不能不谈一谈死锁，略一分析就能发现，suspend() 方法和不指定超时期限的 wait() 方法的调用都可能产生死锁。遗憾的是，Java 并不在语言级别上支持死锁的避免，我们在编程中必须小心地避免死锁。<br>以上我们对 Java 中实现线程阻塞的各种方法作了一番分析，我们重点分析了 wait() 和 notify() 方法，因为它们的功能最强大，使用也最灵活，但是这也导致了它们的效率较低，较容易出错。实际使用中我们应该灵活使用各种方法，以便更好地达到我们的目的。<br><strong>产生死锁的条件</strong><br>1.互斥条件：一个资源每次只能被一个进程使用。<br>2.请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>3.不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。<br>4.循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。<br><strong>为什么wait()方法和notify()/notifyAll()方法要在同步块中被调用</strong><br>这是JDK强制的，wait()方法和notify()/notifyAll()方法在调用前都必须先获得对象的锁<br><strong>wait()方法和notify()/notifyAll()方法在放弃对象监视器时有什么区别</strong><br>wait()方法和notify()/notifyAll()方法在放弃对象监视器的时候的区别在于：wait()方法立即释放对象监视器，notify()/notifyAll()方法则会等待线程剩余代码执行完毕才会放弃对象监视器。<br><strong>wait()与sleep()的区别</strong><br>关于这两者已经在上面进行详细的说明,这里就做个概括好了:<br>· sleep()来自Thread类，和wait()来自Object类.调用sleep()方法的过程中，线程不会释放对象锁。而 调用 wait 方法线程会释放对象锁<br>· sleep()睡眠后不出让系统资源，wait让其他线程可以占用CPU<br>· sleep(milliseconds)需要指定一个睡眠时间，时间一到会自动唤醒.而wait()需要配合notify()或者notifyAll()使用<br><strong>为什么wait,nofity和nofityAll这些方法不放在Thread类当中</strong><br>一个很明显的原因是JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。<br><strong>怎么唤醒一个阻塞的线程</strong><br>如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。<br><strong>什么是多线程的上下文切换</strong><br>多线程的上下文切换是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。<br><strong>synchronized和ReentrantLock的区别</strong><br>synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上：<br>（1）ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁<br>（2）ReentrantLock可以获取各种锁的信息<br>（3）ReentrantLock可以灵活地实现多路通知<br>另外，二者的锁机制其实也是不一样的:ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word.<br><strong>FutureTask是什么</strong><br>这个其实前面有提到过，FutureTask表示一个异步运算的任务。FutureTask里面可以传入一个Callable的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。当然，由于FutureTask也是Runnable接口的实现类，所以FutureTask也可以放入线程池中。<br><strong>一个线程如果出现了运行时异常怎么办?</strong><br>如果这个异常没有被捕获的话，这个线程就停止执行了。另外重要的一点是：如果这个线程持有某个某个对象的监视器，那么这个对象监视器会被立即释放<br><strong>Java当中有哪几种锁</strong></p>
<ol>
<li>自旋锁: 自旋锁在JDK1.6之后就默认开启了。基于之前的观察，共享数据的锁定状态只会持续很短的时间，为了这一小段时间而去挂起和恢复线程有点浪费，所以这里就做了一个处理，让后面请求锁的那个线程在稍等一会，但是不放弃处理器的执行时间，看看持有锁的线程能否快速释放。为了让线程等待，所以需要让线程执行一个忙循环也就是自旋操作。在jdk6之后，引入了自适应的自旋锁，也就是等待的时间不再固定了，而是由上一次在同一个锁上的自旋时间及锁的拥有者状态来决定</li>
<li>偏向锁: 在JDK1.之后引入的一项锁优化，目的是消除数据在无竞争情况下的同步原语。进一步提升程序的运行性能。 偏向锁就是偏心的偏，意思是这个锁会偏向第一个获得他的线程，如果接下来的执行过程中，改锁没有被其他线程获取，则持有偏向锁的线程将永远不需要再进行同步。偏向锁可以提高带有同步但无竞争的程序性能，也就是说他并不一定总是对程序运行有利，如果程序中大多数的锁都是被多个不同的线程访问，那偏向模式就是多余的，在具体问题具体分析的前提下，可以考虑是否使用偏向锁。</li>
<li>轻量级锁: 为了减少获得锁和释放锁所带来的性能消耗，引入了“偏向锁”和“轻量级锁”，所以在Java SE1.6里锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁<br><strong>如何在两个线程间共享数据</strong><br>通过在线程之间共享对象就可以了，然后通过wait/notify/notifyAll、await/signal/signalAll进行唤起和等待，比方说阻塞队列BlockingQueue就是为线程之间共享数据而设计的<br><strong>如何正确的使用wait()?使用if还是while?</strong><br>wait() 方法应该在循环调用，因为当线程获取到 CPU 开始执行的时候，其他条件可能还没有满足，所以在处理前，循环检测条件是否满足会更好。下面是一段标准的使用 wait 和 notify 方法的代码：<br>synchronized (obj) {<br>while (condition does not hold)<br>  obj.wait(); <em>// (Releases lock, and reacquires on wakeup)</em><br>  … <em>// Perform action appropriate to condition</em><br>}</li>
</ol>
<p><strong>什么是线程局部变量ThreadLocal</strong><br>线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。<br><strong>ThreadLoal的作用是什么?</strong><br>简单说ThreadLocal就是一种以空间换时间的做法在每个Thread里面维护了一个ThreadLocal.ThreadLocalMap把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了.<br><strong>生产者消费者模型的作用是什么?</strong><br>（1）通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率，这是生产者消费者模型最重要的作用<br>（2）解耦，这是生产者消费者模型附带的作用，解耦意味着生产者和消费者之间的联系少，联系越少越可以独自发展而不需要收到相互的制约<br><strong>写一个生产者-消费者队列</strong><br>可以通过阻塞队列实现,也可以通过wait-notify来实现.<br><strong>使用阻塞队列来实现</strong><br><em>//消费者</em><br>public class Producer implements Runnable{<br>   private final BlockingQueue<integer> queue;</integer></p>
<p>   public Producer(BlockingQueue q){<br>       this.queue=q;<br>   }</p>
<p>   @Override<br>   public void run() {<br>       try {<br>           while (true){<br>               Thread.sleep(1000);<em>//模拟耗时</em><br>               queue.put(produce());<br>           }<br>       }catch (InterruptedException e){</p>
<pre><code>}
</code></pre><p>   }</p>
<p>   private int produce() {<br>       int n=new Random().nextInt(10000);<br>       System.out.println(“Thread:” + Thread.currentThread().getId() + “ produce:” + n);<br>       return n;<br>   }<br>}<br><em>//消费者</em><br>public class Consumer implements Runnable {<br>   private final BlockingQueue<integer> queue;</integer></p>
<p>   public Consumer(BlockingQueue q){<br>       this.queue=q;<br>   }</p>
<p>   @Override<br>   public void run() {<br>       while (true){<br>           try {<br>               Thread.sleep(2000);<em>//模拟耗时</em><br>               consume(queue.take());<br>           }catch (InterruptedException e){</p>
<pre><code>    }

}
</code></pre><p>   }</p>
<p>   private void consume(Integer n) {<br>       System.out.println(“Thread:” + Thread.currentThread().getId() + “ consume:” + n);</p>
<p>   }<br>}<br><em>//测试</em><br>public class Main {</p>
<p>   public static void main(String[] args) {<br>       BlockingQueue<integer> queue=new ArrayBlockingQueue<integer>(100);<br>       Producer p=new Producer(queue);<br>       Consumer c1=new Consumer(queue);<br>       Consumer c2=new Consumer(queue);</integer></integer></p>
<pre><code>new Thread(p).start();
new Thread(c1).start();
new Thread(c2).start();
</code></pre><p>   }<br>}</p>
<p><strong>使用wait-notify来实现</strong><br>该种方式应该最经典,这里就不做说明了<br><strong>如果你提交任务时，线程池队列已满，这时会发生什么</strong><br>如果你使用的LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为LinkedBlockingQueue可以近乎认为是一个无穷大的队列，可以无限存放任务；如果你使用的是有界队列比方说ArrayBlockingQueue的话，任务首先会被添加到ArrayBlockingQueue中，ArrayBlockingQueue满了，则会使用拒绝策略RejectedExecutionHandler处理满了的任务，默认是AbortPolicy。<br><strong>为什么要使用线程池</strong><br>避免频繁地创建和销毁线程，达到线程对象的重用。另外，使用线程池还可以根据项目灵活地控制并发的数目。<br><strong>java中用到的线程调度算法是什么</strong><br>抢占式。一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。<br><strong>Thread.sleep(0)的作用是什么</strong><br>由于Java采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到CPU控制权的情况，为了让某些优先级比较低的线程也能获取到CPU控制权，可以使用Thread.sleep(0)手动触发一次操作系统分配时间片的操作，这也是平衡CPU控制权的一种操作。<br><strong>什么是CAS</strong><br>CAS，全称为Compare and Swap，即比较-替换。假设有三个操作数：内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，才会将内存值修改为B并返回true，否则什么都不做并返回false。当然CAS一定要volatile变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值，否则旧的预期值A对某条线程来说，永远是一个不会变的值A，只要某次CAS操作失败，永远都不可能成功<br><strong>什么是乐观锁和悲观锁</strong><br>乐观锁：乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。<br>悲观锁：悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。<br><strong>ConcurrentHashMap的并发度是什么?</strong><br>ConcurrentHashMap的并发度就是segment的大小，默认为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这也是ConcurrentHashMap对Hashtable的最大优势，任何情况下，Hashtable能同时有两条线程获取Hashtable中的数据吗？<br><strong>ConcurrentHashMap的工作原理</strong><br>ConcurrentHashMap在jdk 1.6和jdk 1.8实现原理是不同的.<br><strong>jdk 1.6:</strong><br>ConcurrentHashMap是线程安全的，但是与Hashtablea相比，实现线程安全的方式不同。Hashtable是通过对hash表结构进行锁定，是阻塞式的，当一个线程占有这个锁时，其他线程必须阻塞等待其释放锁。ConcurrentHashMap是采用分离锁的方式，它并没有对整个hash表进行锁定，而是局部锁定，也就是说当一个线程占有这个局部锁时，不影响其他线程对hash表其他地方的访问。<br>具体实现:ConcurrentHashMap内部有一个Segment<br><strong>jdk 1.8</strong><br>在jdk 8中，ConcurrentHashMap不再使用Segment分离锁，而是采用一种乐观锁CAS算法来实现同步问题，但其底层还是“数组+链表-&gt;红黑树”的实现。<br><strong>CyclicBarrier和CountDownLatch区别</strong><br>这两个类非常类似，都在java.util.concurrent下，都可以用来表示代码运行到某个点上，二者的区别在于：<br>· CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值-1而已，该线程继续运行<br>· CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务<br>· CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了<br><strong>java中的++操作符线程安全么?</strong><br>不是线程安全的操作。它涉及到多个指令，如读取变量值，增加，然后存储回内存，这个过程可能会出现多个线程交差<br><strong>你有哪些多线程开发良好的实践?</strong></p>
<ol>
<li>给线程命名</li>
<li>最小化同步范围</li>
<li>优先使用volatile</li>
<li>尽可能使用更高层次的并发工具而非wait和notify()来实现线程通信,如BlockingQueue,Semeaphore</li>
<li>优先使用并发容器而非同步容器.</li>
<li>考虑使用线程池</li>
</ol>
<p><strong>关于volatile关键字</strong><br><strong>可以创建Volatile数组吗?</strong><br>Java 中可以创建 volatile类型数组，不过只是一个指向数组的引用，而不是整个数组。如果改变引用指向的数组，将会受到volatile 的保护，但是如果多个线程同时改变数组的元素，volatile标示符就不能起到之前的保护作用了<br><strong>volatile能使得一个非原子操作变成原子操作吗?</strong><br>一个典型的例子是在类中有一个 long 类型的成员变量。如果你知道该成员变量会被多个线程访问，如计数器、价格等，你最好是将其设置为 volatile。为什么？因为 Java 中读取 long 类型变量不是原子的，需要分成两步，如果一个线程正在修改该 long 变量的值，另一个线程可能只能看到该值的一半（前 32 位）。但是对一个 volatile 型的 long 或 double 变量的读写是原子。<br>一种实践是用 volatile 修饰 long 和 double 变量，使其能按原子类型来读写。double 和 long 都是64位宽，因此对这两种类型的读是分为两部分的，第一次读取第一个 32 位，然后再读剩下的 32 位，这个过程不是原子的，但 Java 中 volatile 型的 long 或 double 变量的读写是原子的。volatile 修复符的另一个作用是提供内存屏障（memory barrier），例如在分布式框架中的应用。简单的说，就是当你写一个 volatile 变量之前，Java 内存模型会插入一个写屏障（write barrier），读一个 volatile 变量之前，会插入一个读屏障（read barrier）。意思就是说，在你写一个 volatile 域时，能保证任何线程都能看到你写的值，同时，在写之前，也能保证任何数值的更新对所有线程是可见的，因为内存屏障会将其他所有写的值更新到缓存。<br><strong>volatile类型变量提供什么保证?</strong><br>volatile 主要有两方面的作用:1.避免指令重排2.可见性保证.例如，JVM 或者 JIT为了获得更好的性能会对语句重排序，但是 volatile 类型变量即使在没有同步块的情况下赋值也不会与其他语句重排序。 volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。某些情况下，volatile 还能提供原子性，如读 64 位数据类型，像 long 和 double 都不是原子的(低32位和高32位)，但 volatile 类型的 double 和 long 就是原子的.</p>
<p><strong>关于集合</strong><br><strong>Java中的集合及其继承关系</strong><br>关于集合的体系是每个人都应该烂熟于心的,尤其是对我们经常使用的List,Map的原理更该如此.这里我们看这张图即可:<br><img src="https://shimo.im/fake.png" alt="图片"><br>更多内容可见集合类总结：<br><a href="http://write.blog.csdn.net/postedit/40826423" target="_blank" rel="noopener">http://write.blog.csdn.net/postedit/40826423</a><br><strong>poll()方法和remove()方法区别?</strong><br>poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。<br><strong>LinkedHashMap和PriorityQueue的区别</strong><br>PriorityQueue 是一个优先级队列,保证最高或者最低优先级的的元素总是在队列头部，但是 LinkedHashMap 维持的顺序是元素插入的顺序。当遍历一个 PriorityQueue 时，没有任何顺序保证，但是 LinkedHashMap 课保证遍历顺序是元素插入的顺序。<br><strong>WeakHashMap与HashMap的区别是什么?</strong><br>WeakHashMap 的工作与正常的 HashMap 类似，但是使用弱引用作为 key，意思就是当 key 对象没有任何引用时，key/value 将会被回收。<br><strong>ArrayList和LinkedList的区别?</strong><br>最明显的区别是 ArrrayList底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构是双向循环链表，不支持随机访问。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。<br><strong>ArrayList和Array有什么区别?</strong></p>
<ol>
<li>Array可以容纳基本类型和对象，而ArrayList只能容纳对象。</li>
<li>Array是指定大小的，而ArrayList大小是固定的<br><strong>ArrayList和HashMap默认大小?</strong><br>在 Java 7 中，ArrayList 的默认大小是 10 个元素，HashMap 的默认大小是16个元素（必须是2的幂）。这就是 Java 7 中 ArrayList 和 HashMap 类的代码片段<br>private static final int DEFAULT_CAPACITY = 10;</li>
</ol>
<p><em>//from HashMap.java JDK 7</em><br>static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; <em>// aka 16</em></p>
<p><strong>Comparator和Comparable的区别?</strong><br>Comparable 接口用于定义对象的自然顺序，而 comparator 通常用于定义用户定制的顺序。Comparable 总是只有一个，但是可以有多个 comparator 来定义对象的顺序。<br><strong>如何实现集合排序?</strong><br>你可以使用有序集合，如 TreeSet 或 TreeMap，你也可以使用有顺序的的集合，如 list，然后通过 Collections.sort() 来排序。<br><strong>如何打印数组内容</strong><br>你可以使用 Arrays.toString() 和 Arrays.deepToString() 方法来打印数组。由于数组没有实现 toString() 方法，所以如果将数组传递给 System.out.println() 方法，将无法打印出数组的内容，但是 Arrays.toString() 可以打印每个元素。<br><strong>LinkedList的是单向链表还是双向?</strong><br>双向循环列表,具体实现自行查阅源码.<br><strong>TreeMap是实现原理</strong><br>采用红黑树实现,具体实现自行查阅源码.<br><strong>遍历ArrayList时如何正确移除一个元素</strong><br>该问题的关键在于面试者使用的是 ArrayList 的 remove() 还是 Iterator 的 remove()方法。这有一段示例代码，是使用正确的方式来实现在遍历的过程中移除元素，而不会出现 ConcurrentModificationException 异常的示例代码。<br><strong>什么是ArrayMap?它和HashMap有什么区别?</strong><br>ArrayMap是Android SDK中提供的,非Android开发者可以略过.<br>ArrayMap是用两个数组来模拟map,更少的内存占用空间,更高的效率.<br>具体参考这篇文章:ArrayMap VS HashMap：<a href="http://lvable.com/?p=217%5D" target="_blank" rel="noopener">http://lvable.com/?p=217%5D</a><br><strong>HashMap的实现原理</strong><br>1 HashMap概述： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。<br>2 HashMap的数据结构： 在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。<br>当我们往Hashmap中put元素时,首先根据key的hashcode重新计算hash值,根绝hash值得到这个元素在数组中的位置(下标),如果该数组在该位置上已经存放了其他元素,那么在这个位置上的元素将以链表的形式存放,新加入的放在链头,最先加入的放入链尾.如果数组中该位置没有元素,就直接将该元素放到数组的该位置上.<br>需要注意Jdk 1.8中对HashMap的实现做了优化,当链表中的节点数据超过八个之后,该链表会转为红黑树来提高查询效率,从原来的O(n)到O(logn)<br><strong>你了解Fail-Fast机制吗</strong><br>Fail-Fast即我们常说的快速失败,<br>更多内容参看fail-fast机制：<a href="http://blog.csdn.net/chenssy/article/details/38151189" target="_blank" rel="noopener">http://blog.csdn.net/chenssy/article/details/38151189</a><br><strong>Fail-fast和Fail-safe有什么区别</strong><br>Iterator的fail-fast属性与当前的集合共同起作用，因此它不会受到集合中任何改动的影响。Java.util包中的所有集合类都被设计为fail-&gt;fast的，而java.util.concurrent中的集合类都为fail-safe的。当检测到正在遍历的集合的结构被改变时，Fail-fast迭代器抛出ConcurrentModificationException，而fail-safe迭代器从不抛出ConcurrentModificationException。</p>
<p><strong>关于日期</strong><br><strong>SimpleDateFormat是线程安全的吗?</strong><br>非常不幸，DateFormat 的所有实现，包括 SimpleDateFormat 都不是线程安全的，因此你不应该在多线程序中使用，除非是在对外线程安全的环境中使用，如 将 SimpleDateFormat 限制在 ThreadLocal 中。如果你不这么做，在解析或者格式化日期的时候，可能会获取到一个不正确的结果。因此，从日期、时间处理的所有实践来说，我强力推荐 joda-time 库。<br><strong>如何格式化日期?</strong><br>Java 中，可以使用 SimpleDateFormat 类或者 joda-time 库来格式日期。DateFormat 类允许你使用多种流行的格式来格式化日期。参见答案中的示例代码，代码中演示了将日期格式化成不同的格式，如 dd-MM-yyyy 或 ddMMyyyy。</p>
<p><strong>关于异常</strong><br><strong>简单描述java异常体系</strong><br>相比没有人不了解异常体系,关于异常体系的更多信息可以见<br>白话异常机制：<a href="http://blog.csdn.net/dd864140130/article/details/42504189" target="_blank" rel="noopener">http://blog.csdn.net/dd864140130/article/details/42504189</a><br><strong>什么是异常链</strong><br>详情直接参见上面的白话异常机制,不做解释了.<br><strong>throw和throws的区别</strong><br>throw用于主动抛出java.lang.Throwable 类的一个实例化对象，意思是说你可以通过关键字 throw 抛出一个 Error 或者 一个Exception，如：throw new IllegalArgumentException(“size must be multiple of 2″),<br>而throws 的作用是作为方法声明和签名的一部分，方法被抛出相应的异常以便调用者能处理。Java 中，任何未处理的受检查异常强制在 throws 子句中声明。</p>
<p><strong>关于序列化</strong><br><strong>Java 中，Serializable 与 Externalizable 的区别</strong><br>Serializable 接口是一个序列化 Java 类的接口，以便于它们可以在网络上传输或者可以将它们的状态保存在磁盘上，是 JVM 内嵌的默认序列化方式，成本高、脆弱而且不安全。Externalizable 允许你控制整个序列化过程，指定特定的二进制格式，增加安全机制。</p>
<p><strong>关于JVM</strong><br><strong>JVM特性</strong><br>平台无关性.<br>Java语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用模式Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。<br><strong>简单解释一下类加载器</strong><br>有关类加载器一般会问你四种类加载器的应用场景以及双亲委派模型,<br>更多的内容参看深入理解JVM加载器：<br><a href="http://blog.csdn.net/dd864140130/article/details/49817357" target="_blank" rel="noopener">http://blog.csdn.net/dd864140130/article/details/49817357</a><br><strong>简述堆和栈的区别</strong><br>VM 中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。<br><strong>简述JVM内存分配</strong></p>
<ol>
<li>基本数据类型比变量和对象的引用都是在栈分配的</li>
<li>堆内存用来存放由new创建的对象和数组</li>
<li>类变量（static修饰的变量），程序在一加载的时候就在堆中为类变量分配内存，堆中的内存地址存放在栈中</li>
<li>实例变量：当你使用java关键字new的时候，系统在堆中开辟并不一定是连续的空间分配给变量，是根据零散的堆内存地址，通过哈希算法换算为一长串数字以表征这个变量在堆中的”物理位置”,实例变量的生命周期–当实例变量的引用丢失后，将被GC（垃圾回收器）列入可回收“名单”中，但并不是马上就释放堆中内存</li>
<li>局部变量: 由声明在某方法，或某代码段里（比如for循环），执行到它的时候在栈中开辟内存，当局部变量一但脱离作用域，内存立即释放</li>
</ol>
<p><strong>其他</strong><br><strong>java当中采用的是大端还是小端?</strong><br><strong>XML解析的几种方式和特点</strong><br>DOM,SAX,PULL三种解析方式:<br>· DOM:消耗内存：先把xml文档都读到内存中，然后再用DOM API来访问树形结构，并获取数据。这个写起来很简单，但是很消耗内存。要是数据过大，手机不够牛逼，可能手机直接死机<br>· SAX:解析效率高，占用内存少，基于事件驱动的：更加简单地说就是对文档进行顺序扫描，当扫描到文档(document)开始与结束、元素(element)开始与结束、文档(document)结束等地方时通知事件处理函数，由事件处理函数做相应动作，然后继续同样的扫描，直至文档结束。<br>· PULL:与 SAX 类似，也是基于事件驱动，我们可以调用它的next（）方法，来获取下一个解析事件（就是开始文档，结束文档，开始标签，结束标签），当处于某个元素时可以调用XmlPullParser的getAttributte()方法来获取属性的值，也可调用它的nextText()获取本节点的值。<br><strong>JDK 1.7特性</strong><br>然 JDK 1.7 不像 JDK 5 和 8 一样的大版本，但是，还是有很多新的特性，如 try-with-resource 语句，这样你在使用流或者资源的时候，就不需要手动关闭，Java 会自动关闭。Fork-Join 池某种程度上实现 Java 版的 Map-reduce。允许 Switch 中有 String 变量和文本。菱形操作符(&lt;&gt;)用于类型推断，不再需要在变量声明的右边申明泛型，因此可以写出可读写更强、更简洁的代码<br><strong>JDK 1.8特性</strong><br>java 8 在 Java 历史上是一个开创新的版本，下面 JDK 8 中 5 个主要的特性：<br>Lambda 表达式，允许像对象一样传递匿名函数<br>Stream API，充分利用现代多核 CPU，可以写出很简洁的代码<br>Date 与 Time API，最终，有一个稳定、简单的日期和时间库可供你使用<br>扩展方法，现在，接口中可以有静态、默认方法。<br>重复注解，现在你可以将相同的注解在同一类型上使用多次。<br><strong>Maven和ANT有什么区别?</strong><br>虽然两者都是构建工具，都用于创建 Java 应用，但是 Maven 做的事情更多，在基于“约定优于配置”的概念下，提供标准的Java 项目结构，同时能为应用自动管理依赖（应用中所依赖的 JAR 文件.<br><strong>JDBC最佳实践</strong><br>· 优先使用批量操作来插入和更新数据<br>· 使用PreparedStatement来避免SQL漏洞<br>· 使用数据连接池<br>· 通过列名来获取结果集<br><strong>IO操作最佳实践</strong><br>· 使用有缓冲的IO类,不要单独读取字节或字符<br>· 使用NIO和NIO 2或者AIO,而非BIO<br>· 在finally中关闭流<br>· 使用内存映射文件获取更快的IO</p>
<p><strong>好的东西要和朋友一起分享，赶快将本文分享给你身边正在准备Java面试的朋友吧！</strong></p>
<p>●编号684，输入编号直达本文<br>●输入m获取文章目录<br><strong>推荐↓↓↓</strong><br><img src="https://shimo.im/fake.png" alt="图片"><br><strong>Python编程</strong><br><strong>更多推荐：《</strong><a href="http://#wechat_redirect" target="_blank" rel="noopener">18个技术类微信公众号</a><strong>》</strong><br>涵盖：程序人生、算法与数据结构、黑客技术与网络安全、大数据技术、前端开发、Java、Python、Web开发、安卓开发、iOS开发、C/C++、.NET、Linux、数据库、运维等。<br><a href="http://##" target="_blank" rel="noopener">阅读原文</a><br><img src="https://shimo.im/fake.png" alt="图片"><br>微信扫一扫<br>关注该公众号</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://Syq777.github.io/2019/04/29/面试/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Syq">
      <meta itemprop="description" content="寻门而入，破门而出。">
      <meta itemprop="image" content="/images/image.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/29/面试/" class="post-title-link" itemprop="url">面试</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-29 00:03:32 / 修改时间：00:13:13" itemprop="dateCreated datePublished" datetime="2019-04-29T00:03:32+08:00">2019-04-29</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/面试/" itemprop="url" rel="index"><span itemprop="name">面试</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h6 id="面试总结-子元哥"><a href="#面试总结-子元哥" class="headerlink" title="面试总结(子元哥)"></a>面试总结(子元哥)</h6><p>自己做的模板<br>经验项目<br>不要说培训经历，项目<br>合作<br>住的<br>大公司实习<br>培训几个月干活的不要去<br>4000<br>se  数据库  算法  排序 数据结构<br>框架<br>不要太急<br>两轮面试</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://Syq777.github.io/2019/04/28/大数据云计算虚拟化概念区分/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Syq">
      <meta itemprop="description" content="寻门而入，破门而出。">
      <meta itemprop="image" content="/images/image.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/28/大数据云计算虚拟化概念区分/" class="post-title-link" itemprop="url">大数据云计算虚拟化概念区分</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-28 23:59:10" itemprop="dateCreated datePublished" datetime="2019-04-28T23:59:10+08:00">2019-04-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-29 00:25:54" itemprop="dateModified" datetime="2019-04-29T00:25:54+08:00">2019-04-29</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/概念/" itemprop="url" rel="index"><span itemprop="name">概念</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h6 id="云计算是什么"><a href="#云计算是什么" class="headerlink" title="云计算是什么"></a>云计算是什么</h6><p>官方解释：云计算是一种按使用量付费的模式，这种模式提供可用的、便捷的、按需的网络访问， 进入可配置的计算资源共享池（资源包括网络，服务器，存储，应用软件，服务），这些资源能够被快速提供，只需投入很少的管理工作，或与服务供应商进行很少的交互。</p>
<p>我们应该如何通俗地理解：<br>首先按照传统方式建立网站，要怎么做呢？需要购买服务器，网络带宽，注册网站域名，开发，运维等一系列复杂的过程，最后才能建立起来我的网站。就好像是我们想要获得干净的水源，前期需要购置很多工具，花费大量人力，最后才能打出来一口井。</p>
<p>云计算是什么？通俗理解就是有一个云厂商已经建立好了自来水井，也铺好了自来水管道，我们直接拿被子取干净的水就好了，这就是一套自来水系统。不用再去打水井，铺管道，提高了时间效率，也大大降低了人力成本。</p>
<p>云计算是如何分类的<br>云计算一般分为三类：基础架构即服务（IaaS）、平台即服务（PaaP）和软件即服务（SaaS）</p>
<p>基础架构即服务（IaaS）<br>也就是基础设施服务，主要是通过网络的方式向用户提供计算，储存，网络等基础资源。目前中小型企业或用户都是购买这类基础性框架服务。通俗理解就是从水厂的水源，厂房，自来水管道，这类属于最基础的设施。</p>
<p>平台即服务（PaaP）<br>主要是通过平台向用户提供应用软件的开发，测试，快速部署，帮助用户快速实现更多应用功能。主要针对互联网公司，比较成型规模的公司。通俗理解就是为了达到特定的目的而提供的工具，如过滤的工具，增加矿物质的工具，增加二氧化碳含量的工具，也就是为这个自来水持续地增加它的价值。</p>
<p>软件即服务（SaaS）<br>直接加工成商品性的东西去卖就好了，通俗理解就是直接获得自来水，将水再加工处理，做成特定的产品卖出去，如纯净水，苏打水，农夫山泉，怡宝等这类产品。</p>
<hr>
<ol>
<li>虚拟化及分类</li>
</ol>
<p>虚拟化是指计算机元件在虚拟的基础上而不是真实的基础上运行。虚拟化技术可以扩大硬件的容量，简化软件的重新配置过程。CPU的虚拟化技术可以单CPU模拟多CPU并行，允许一个平台同时运行多个操作系统，并且应用程序都可以在相互独立的空间内运行而互不影响，从而显著提高计算机的工作效率。</p>
<p>  顾名思义，虚拟化就是在计算上虚拟出一些实际计算机里真实存在的东西，以达到更方便、简单、成本低、安全性高的目的。比如，虚拟计算机硬件，可以安装操作系统;以现有操作系统为蓝本，再虚拟出几个一摸一样的;虚拟一个操作系统环境，可以安装应用软件。这个解释，是本人很通俗的说法，严格精准的定义，至今还未看到。</p>
<p>　</p>
<p>1.1 以实现层次来分：硬件虚拟化，操作系统虚拟化，应用程序虚拟化。<br>    言归正传，现在按照不同属性，对虚拟化做一个分类：<br>    以被应用的领域来划分：服务器虚拟化、存储虚拟化、网络虚拟化、桌面虚拟化。<br>  还有从以某类里衍生出来的，无法归类，比如cpu虚拟化，文件虚拟化。<br>  这些不用属性的类别之间的关系又是交错联系的，下面逐一简单介绍一下。</p>
<p>1.1.1 硬件虚拟化<br>  硬件虚拟化，就是用软件来虚拟一台标准电脑的硬件配置，如cpu、内存、硬盘、声显卡、光驱等，成为一台虚拟的裸机，然后就可以在上面安装操作系统了，其代表产品VMware。</p>
<p>  使用时，先在操作系统里安装一个硬件虚拟化软件，用其虚拟出一台电脑，再安装系统，做到系统里运行系统，并可虚拟出多台电脑，安装多个相同或不同的系统。</p>
<p>  其代表产品为VMware，其余几个知名的有：微软的Virtual PC，开源免费的VirtualBox。</p>
<p>  为虚拟机分配的硬件资源要占用实际硬件的资源，对性能损耗也较大。因为是在系统里安装虚拟化软件，再在虚拟的电脑上装系统，所以就有原系统和虚拟化软件两层消耗，为了提高性能，出现了另外一种硬件虚拟化形式：直接在裸机上安装虚拟化软件，然后安装多个系统，并同时运行。跳过原系统这一环节，性能大大提高。这种虚拟化又叫做准虚拟化。VMware推出的相关产品叫VMware ESXi，微软的该类产品为Hyper-V，主要应用于服务器领域。</p>
<p>1.1.2  操作系统虚拟化（OS-level virtualization）<br>  操作系统虚拟化就是以一个系统为母体，克隆出多个系统。它比硬件虚拟化要灵活方便，因为只需在系统里装一个虚拟化软件，就能以原系统为样本，很快克隆出系统，克隆出的系统与原系统除去一些ID标识外，其余都一样。</p>
<p>  看似与硬件虚拟化一样，都是虚拟多个操作系统出来，但与硬件虚拟化还是很多不同之处：</p>
<ol>
<li><p>操作系统虚拟化是以原系统为样本，虚拟出一个近乎一摸一样的系统;硬件虚拟化是虚拟硬件环境，然后真实的安装系统。它们虚拟的东西不一样。</p>
</li>
<li><p>操作系统虚拟化，虚拟的系统都只能为同样的系统;硬件虚拟化，虚拟的系统可以为不同的系统，如linnux、mac、windows家族。</p>
</li>
<li><p>操作系统虚拟化，虚拟的多个系统有较强的联系，体现在：第一，可以多个虚拟系统同时进行配置，更改了原系统，就改了所有;第二，如果原系统损坏，会殃及所有虚拟系统。硬件虚拟化虚拟的多个系统，是相互独立，与原系统也无联系。原系统的损坏不会殃及虚拟的系统。</p>
</li>
<li><p>操作系统虚拟化的性能损耗低，它们都是虚拟的系统，而非硬件虚拟化那样真实安装的实体;没有硬件虚拟化的虚拟硬件层，也大大降低了性能损耗。</p>
</li>
</ol>
<p>这种方式由FreeBSD jails首创；类似的例子包括Solaris Containers， OpenVZ， Linux-VServer， AIX Workload Partitions， Parallels Virtuozzo Containers， 以及 iCore Virtual Accounts。</p>
<p>1.1.3 应用虚拟化<br>  前两种虚拟化技术，大多应用于企业、服务器和一些IT专业工作领域。随着虚拟化技术的发展，逐渐从企业往个人、专业往大众应用的趋势发展，便出现了应用程序虚拟化技术，简称应用虚拟化。它近年虚拟化的新贵和热门领域。</p>
<p>  前两种虚拟化的目的是虚拟完整的真实的操作系统，应用虚拟化的目的也是虚拟操作系统，但只是为保证应用程序的正常运行虚拟系统的某些关键部分，如注册表、C盘环境等，所以较为轻量、小巧。</p>
<p>1.2 根据虚拟化程度分为：软件全虚拟化、软件半虚拟化和硬件辅助虚拟化<br>    纯软件的“全虚拟化”方式不需要修改客户机操作系统，但是其性能较未虚拟化时影响比较大。支持完全虚拟化的虚拟机软件包括VMware Workstation和Virtual PC等。</p>
<pre><code>半虚拟化模式，这种模式需要对客户机操作系统进行更改，使得客户机操作系统知道其运行在虚拟化环境下，从而可以获得更高的性能。半虚拟化的典型产品包括Xen、UML等。



看虚拟化技术是完全虚拟化还是半虚拟化，首先看虚拟化技术有没有修改内核，xen虚拟化技术需要修改内核，因此它有完全虚拟化和半虚拟化之分，kvm没有修改内核，因此，它只有完全虚拟化；还要看cpu是否支持硬件虚拟化，支持硬件虚拟化，就是完全虚拟化，不支持，就是半虚拟化。xen有两种选择，而kvm只有一种选择，所以，xen有完全虚拟化和半虚拟化之分，kvm只有完全虚拟化。



硬件辅助虚拟化技术，在处理器中加入了新的特权级来运行虚拟机监控层，使得客户机操作系统可以运行在原始特权级，不需要更改，并且由硬件来完成两个特权级之间的转换。硬件辅助虚拟技术提高了虚拟机的兼容性和性能。支持硬件辅助虚拟化的有 Linux KVM和Xen等。
</code></pre><p>1.3 按照虚拟层次分为：分为程序级虚拟化和系统级虚拟化<br>  前者通常是在应用层上创建虚拟机，这种虚拟机通常是为了运行应用程序而创建，并且随着应用程序的退出而结束。应用级虚拟机的一个典型例子就是Java虚拟机（JVM）。<br>系统级虚拟化包括一个Hypervisor或者VMM（Virtual Machine Monitor）。Hypervisor是位于硬件资源和操作系统之间的软件层。它使得多个单独的虚拟机实例可以同时运行，并使得多个虚拟机可以共享各种物理硬件资源。Hypervisor协调这些硬件资源（CPU、内存和各种I/O设备）的访问，为虚拟机分配各种需要使用的资源。</p>
<p>   对于系统级虚拟化，根据虚拟机监视器 Hypervisor或VMM的实现层次，主要可以分为基于宿主操作系统的系统级虚拟化和基于硬件的系统级虚拟化。</p>
<p>基于宿主操作系统的虚拟机作为应用程序运行在宿主操作系统（Host OS）之上，其架构如图1 所示。因此Guest VM需要由Guest Os内核先经过Hypervisor，再经过宿主操作系统才能访问硬件。支持基于宿主操作系统虚拟化的产品有 Virtual PC、VMWare Workstation和VirtualBox等。</p>
<p>Docker的思想来自于集装箱，集装箱解决了什么问题？在一艘大船上，可以把货物规整的摆放起来。并且各种各样的货物被集装箱标准化了，集装箱和集装箱之间不会互相影响。那么我就不需要专门运送水果的船和专门运送化学品的船了。只要这些货物在集装箱里封装的好好的，那我就可以用一艘大船把他们都运走。docker就是类似的理念。现在都流行云计算了，云计算就好比大货轮。docker就是集装箱。1.不同的应用程序可能会有不同的应用环境，比如.net开发的网站和php开发的网站依赖的软件就不一样，如果把他们依赖的软件都安装在一个服务器上就要调试很久，而且很麻烦，还会造成一些冲突。比如IIS和Apache访问端口冲突。这个时候你就要隔离.net开发的网站和php开发的网站。常规来讲，我们可以在服务器上创建不同的虚拟机在不同的虚拟机上放置不同的应用，但是虚拟机开销比较高。docker可以实现虚拟机隔离应用环境的功能，并且开销比虚拟机小，小就意味着省钱了。2.你开发软件的时候用的是Ubuntu，但是运维管理的都是centos，运维在把你的软件从开发环境转移到生产环境的时候就会遇到一些Ubuntu转centos的问题，比如：有个特殊版本的数据库，只有Ubuntu支持，centos不支持，在转移的过程当中运维就得想办法解决这样的问题。这时候要是有docker你就可以把开发环境直接封装转移给运维，运维直接部署你给他的docker就可以了。而且部署速度快。3.在服务器负载方面，如果你单独开一个虚拟机，那么虚拟机会占用空闲内存的，docker部署的话，这些内存就会利用起来。总之docker就是集装箱原理。<br>【知乎精选】如何准确又通俗易懂地解释大数据及其应用价值？</p>
<p>【Wikipedia词条解释】</p>
<p>Big data is a collection of data sets so large and complex that it becomes difficult to process using on-hand database management tools or traditional data processing applications. The challenges include capture, curation, storage, search, sharing, transfer, analysis, and visualization. The trend to larger data sets is due to the additional information derivable from analysis of a single large set of related data, as compared to separate smaller sets with the same total amount of data, allowing correlations to be found to “spot business trends, determine quality of research, prevent diseases, link legal citations, combat crime, and determine real-time roadway traffic conditions.”</p>
<p>大数据说到底就是一个大字。到底有多大？拿维基百科上的例子来说，CERN做的LHC（大型強子對撞機）周长27公里，里面一共有1.5亿个传感器，每秒钟读数达四千万次。每秒钟发生的粒子对撞高达6亿次。剔除99.999%的无用数据，每秒钟也有100次碰撞需要记录。如果在这些数据里面仅仅使用十万分之一，那么一年也要积累25 petabytes的数据，相当于25000个1TB的硬盘。</p>
<p>在这些数据里寻找希格斯玻色子的证据，是真正的大海捞针。这么大的数据你给我用Excel算算看？不要说计算，根本连载入内存都不可能。</p>
<p>再比如说，Facebook据说拥有500亿以上的用户照片。前些日子美国波士顿发生了爆炸案。这些照片里可能就有爆炸案的线索。那你给我找找看那张照片上面有嫌犯？波士顿马拉松仅运动员就有两三万人，围观群众近五十万。在同一时间同一地点拍摄的照片可能有几十万张，录像可能有几千小时。用人工一张一张看过来是不切实际的。如果要考察爆炸案前后几天的照片那就更不现实了。还有的照片根本就没有时间和地点信息。</p>
<p>再举一个例子。2009年华盛顿大学的研究人员使用15万张Flickr上的图片，重建了整个罗马城的3D模型。整个重建过程的计算使用了496个CPU核心，耗时8小时。如果每张照片按100KB计算，总数据量达到15GB。至少要达到这个级别的数据，才能称得上大数据。</p>
<p>大数据因为大，不仅远远超过人工的处理能力，也远远超过普通台式机的处理能力。只有特定的算法和特别设计的硬件架构才能够有效的处理大数据。简单说来，硬件上要把很多CPU或者很多台式机连起来，算法上采取分而治之的策略。有的数据前后没有关联，特别适合分而治之的方法。而处理互相联系多的数据就比较困难。如果只要寻找嫌犯的脸，可以对每张照片分别处理。如果要考虑连续拍摄的照片有些并没有捕捉到脸，但嫌犯的位置和穿着是相对不变的，这就要考虑照片之间的关系，要分而治之就相对困难一些。</p>
<p>举一个做加法的例子来说明分而治之。比如有两道加法题：34+18和54+39。这两道题目如果两个人分别计算，就比一个人计算要快一倍。这就是分治的优势。但是如果只有一道加法题怎么办？比如两个人要计算34+18，那只好一个人计算个位，一个人计算十位。十位上计算3+1=4，但是还必须考虑个位的进位。所以计算十位的人必须等待计算个位的人给出结果之后，再决定要不要在自己的结果上再加1。为了统一结果一等待，计算速度就变慢了，这就是我们说结果之间存在的关系拖慢计算。</p>
<p>既然大数据处理起来这么困难，为什么还要使用大数据？使用小数据不行吗？这就要说到大数据的应用。所谓机器学习，一般是首先建立一个数据之间关系的模型。然后通过数据来确定模型中的参数。这就是所谓训练。大多数模型都是比较简单的。建模的时候为了简便，往往忽略现实中的很多因素。但是数据多了以后，往往可以弥补模型的简陋。所以数据多是有好处的。</p>
<p>那么我们建立一个复杂的模型不行吗？可惜越复杂的模型参数就越多。训练所需要的数据量就越大。随着人类计算能力的增长，能处理的数据量越来越多，统计模型也不断变的更精细更复杂。计算能力，数据量，统计模型三者是相辅相成的。最近兴起的Deep Learning，就是在强大的计算能力辅助下，使用巨大的数据训练多层复杂模型的一种方法。</p>
<p>举一个糖果厂的例子。某糖果厂按比例生产红色和绿色两种糖果。作为一个传统的中国股民，我特别喜欢红色，讨厌绿色。但糖果是包起来的，外面看不出来。那怎么才知道这个糖果厂的生产比例是什么？最简单的模型就是，买一百粒糖果全部剥开看看。比如有60粒红色，我就得出结论说红色比例是0.6。买的糖果越多，估算出的比例和实际比例就越接近。</p>
<p>你说这模型也太弱智了吧。那么好，我们可以考虑食用色素的价格对糖果颜色的影响。通过观察红绿两色色素价格和糖果比例之间的关系，可以预测何时糖果厂会大量生产红色糖果。到时候我就买一堆放家里慢慢吃。但是注意，这计算就需要色素价格的数据了。我们还可以继续构建更加复杂的模型，比如考虑糖果的销量，竞争对手的产品颜色，厂长的心情，天气晴阴等等。考虑的因素越多，需要的数据也越多。</p>
<p>你说扯淡。天气和糖果有什么关系？老实说，有没有关系实在搞不清楚。如果把这个因素放到模型里，多多少少也能算出一点关系来。但算出有关系不代表真有关系。那能不能通过算法自动找出那些因素是真有关系，那些是假装有关系？这就是Deep Learning想要解决的一个问题。</p>
<p>话说回来，只要你考虑的因素正确，又有足够的数据来测算因素之间的关系，那往往可以提升模型的预测能力。所以统计模型在往精细和复杂的方向发展。有些预测能力看起来似乎不可思议。比如预测那些人和你会买同样的书和音乐，比如预测你下班回家的路会不会堵车。有些预测能力似乎稀松平常。比如你一句话还没说完，我大概就能猜到你下一句会说什么。这能力基本上每个人都有，但对计算机来说难如登天，简直如同神迹。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/image.jpg" alt="Syq">
            
              <p class="site-author-name" itemprop="name">Syq</p>
              <div class="site-description motion-element" itemprop="description">寻门而入，破门而出。</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives">
                
                    <span class="site-state-item-count">26</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">18</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">22</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/Syq777" title="GitHub &rarr; https://github.com/Syq777" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:sunwukong0616@gmail.com" title="E-Mail &rarr; mailto:sunwukong0616@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Syq</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.1.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.0"></script>

  <script src="/js/motion.js?v=7.1.0"></script>



  
  


  <script src="/js/affix.js?v=7.1.0"></script>

  <script src="/js/schemes/pisces.js?v=7.1.0"></script>




  

  


  <script src="/js/next-boot.js?v=7.1.0"></script>


  

  

  

  



  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
