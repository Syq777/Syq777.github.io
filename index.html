<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.1.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="寻门而入，破门而出。">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://Syq777.github.io/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="寻门而入，破门而出。">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description" content="寻门而入，破门而出。">





  
  
  <link rel="canonical" href="https://Syq777.github.io/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Hexo</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-首页 menu-item-active">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-标签">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-类别">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>类别</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-档案">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>档案</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://Syq777.github.io/2019/04/29/today_04.29/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Syq">
      <meta itemprop="description" content="寻门而入，破门而出。">
      <meta itemprop="image" content="/images/image.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/29/today_04.29/" class="post-title-link" itemprop="url">today_04.29</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-29 22:51:22 / 修改时间：22:54:09" itemprop="dateCreated datePublished" datetime="2019-04-29T22:51:22+08:00">2019-04-29</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/every-Day/" itemprop="url" rel="index"><span itemprop="name">every_Day</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="04-29"><a href="#04-29" class="headerlink" title="04.29"></a>04.29</h3><h5 id="知识增量："><a href="#知识增量：" class="headerlink" title="知识增量："></a>知识增量：</h5><ol>
<li>无</li>
</ol>
<h5 id="今日收获："><a href="#今日收获：" class="headerlink" title="今日收获："></a>今日收获：</h5><table>
<thead>
<tr>
<th style="text-align:center">早上</th>
<th style="text-align:center">起床时间：7：00</th>
<th style="text-align:center">背单词数量：150</th>
<th style="text-align:center">到图书馆时间：3：00</th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">上午</td>
<td style="text-align:center">小程序</td>
<td style="text-align:center">上课</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">中午</td>
<td style="text-align:center">睡觉</td>
<td style="text-align:center">洗澡</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">下午</td>
<td style="text-align:center">3：00到图书馆</td>
<td style="text-align:center">4：30-5：40张宇视频</td>
<td style="text-align:center">English20min</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">晚上</td>
<td style="text-align:center">6：40-7：40 English</td>
<td style="text-align:center">7：40-闭馆张宇</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">回宿舍后</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><h6 id="可以节约的时间："><a href="#可以节约的时间：" class="headerlink" title="可以节约的时间："></a>可以节约的时间：</h6><p>上课时间没有利用好</p>
<p>单词看的效果不是很好</p>
<h2 id="今日评分：3-0"><a href="#今日评分：3-0" class="headerlink" title="今日评分：3.0"></a>今日评分：3.0</h2>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://Syq777.github.io/2019/04/29/template/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Syq">
      <meta itemprop="description" content="寻门而入，破门而出。">
      <meta itemprop="image" content="/images/image.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/29/template/" class="post-title-link" itemprop="url">template</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-29 00:22:09" itemprop="dateCreated datePublished" datetime="2019-04-29T00:22:09+08:00">2019-04-29</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-25 21:40:35" itemprop="dateModified" datetime="2019-04-25T21:40:35+08:00">2019-04-25</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/template/" itemprop="url" rel="index"><span itemprop="name">template</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://Syq777.github.io/2019/04/29/框架知识点/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Syq">
      <meta itemprop="description" content="寻门而入，破门而出。">
      <meta itemprop="image" content="/images/image.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/29/框架知识点/" class="post-title-link" itemprop="url">框架知识点</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-29 00:19:06 / 修改时间：00:24:33" itemprop="dateCreated datePublished" datetime="2019-04-29T00:19:06+08:00">2019-04-29</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/框架/" itemprop="url" rel="index"><span itemprop="name">框架</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h6 id="框架知识点"><a href="#框架知识点" class="headerlink" title="框架知识点"></a>框架知识点</h6><ol>
<li><p>运用Struts2框架启动tomcat服务显示异常 原因：My<strong>eclipse发布项目的时候并未自动将引用的jar包copy到WEB-INF/目录下，导致编译器找不到所使用的class.</strong><br>需要选中项目,右键选择Properties-&gt;Myeclispe-&gt;Deployment Assembly-&gt;Add以此来自动添加</p>
</li>
<li><p>使用form表单是一定要写上每一个输入框的name属性，不然无法传值，导致不猛登录成功</p>
</li>
<li><p>HttpSession session=request.getSession();是使用session存储值得标配，必须在每一个方法中写上该语句</p>
</li>
<li><p>使用Struts2的验证框架时，必须在struts.xml配置文件中编写result</p>
</li>
<li><result name="”input”">指向目标文件的路径</result>
</li>
<li><p>（1）设计业务逻辑接口、<br>（2）设计业务逻辑接口实现类<br>（3）设计Action类<br>（4）页面调用</p>
</li>
<li><p>超链接也可以连接action</p>
</li>
<li><p>jsp连接到用一文件夹下的其他jsp页面是，文件夹左面不用写“/”;<br>例如:students/Students_add.jsp</p>
</li>
<li><p>spring cloud是建立在spring boot之上</p>
</li>
</ol>
<h6 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h6><ol>
<li>spring （管理工具）</li>
</ol>
<p>IOC(控制反转) 应用程序本身不负责依赖对象德创建和维护，而是由外部容器负责创建和维护<br>通过DI(依赖注入)使应用程序运用逻辑</p>
<p>AOP（面向切面）<br>  面向切面：分离应用的业务逻辑与系统级服务<br>在某种意义上讲是一种容器<br>接口是对内部功能给外界的说明，但是内部如何实现则是保密的<br>面向接口编程  接口名 a=new 接口的实现类<br>Spring bean的配置<br>Bean的配置项Id<br>Class<br>Scpoe</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://Syq777.github.io/2019/04/29/maven框架/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Syq">
      <meta itemprop="description" content="寻门而入，破门而出。">
      <meta itemprop="image" content="/images/image.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/29/maven框架/" class="post-title-link" itemprop="url">maven框架结构</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-29 00:18:44" itemprop="dateCreated datePublished" datetime="2019-04-29T00:18:44+08:00">2019-04-29</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-28 23:53:11" itemprop="dateModified" datetime="2019-04-28T23:53:11+08:00">2019-04-28</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/maven/" itemprop="url" rel="index"><span itemprop="name">maven</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h6 id="maven框架结构"><a href="#maven框架结构" class="headerlink" title="maven框架结构"></a>maven框架结构</h6><p>src<br>   -main<br>        -java<br>               -package<br>   -test<br>        -java<br>              -package<br>    resources</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://Syq777.github.io/2019/04/29/开始屏幕的磁贴一重启就自动还原,求助! - Microsoft Community/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Syq">
      <meta itemprop="description" content="寻门而入，破门而出。">
      <meta itemprop="image" content="/images/image.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/29/开始屏幕的磁贴一重启就自动还原,求助! - Microsoft Community/" class="post-title-link" itemprop="url">开始屏幕的磁贴重启后自动还原</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-29 00:06:26" itemprop="dateCreated datePublished" datetime="2019-04-29T00:06:26+08:00">2019-04-29</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/WIn10/" itemprop="url" rel="index"><span itemprop="name">WIn10</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>您好，</p>
<h6 id="开始屏幕的磁贴重启后自动还原"><a href="#开始屏幕的磁贴重启后自动还原" class="headerlink" title="开始屏幕的磁贴重启后自动还原"></a>开始屏幕的磁贴重启后自动还原</h6><p>了解到您在使用时遇到问题。</p>
<p>我们在测试时，开始磁贴能够正常保存且在该路径下并没有发现您说的文件。</p>
<p>请您尝试使用Dism命令修复下系统。</p>
<p>在小娜中搜索命令提示符，右击以管理员身份运行命令提示符，输入以下命令</p>
<p>扫描映像是否完整：</p>
<p>DISM.exe /Online /Cleanup-image /Scanhealth</p>
<p>完成后再检测映像：</p>
<p>DISM.exe /Online /Cleanup-image /Checkhealth</p>
<p>然后再修复映像：</p>
<p>DISM.exe /Online /Cleanup-image /Restorehealth</p>
<p>最后检查系统并修复：</p>
<p>sfc /scannow</p>
<p>如果问题依旧，请新建一个本地管理员账户，在新建的账户中查看问题是否存在。</p>
<p>在小娜中搜索命令提示符，右击以管理员运行命令提示符，粘贴输入下面两行指令新建一个管理员本地账户：</p>
<p>net user User 789456 /add      （User是新建账户名，789456是新建密码，名称和密码根据需要都可以修改）</p>
<p>net localgroup administrators User /add    （为该账户添加管理员权限）</p>
<p>希望以上信息能够帮助到您。</p>
<p>如果您所咨询的问题，得到解决请对我们的回复进行标记解答（对我们的工作非常重要）</p>
<p>如您的问题没有解决，我们会继续为您提供技术支持。</p>
<p>我们秉承客户至上的服务理念。如果您对微软工程师在论坛中的服务有意见与建议，欢迎提出，以便我们提供更优质的服务。Microsoft Answers欢迎您！</p>
<p>此回复已帮助 1 个人</p>
<p>·</p>
<p>这是否解决了你的问题?</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://Syq777.github.io/2019/04/29/java面试/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Syq">
      <meta itemprop="description" content="寻门而入，破门而出。">
      <meta itemprop="image" content="/images/image.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/29/java面试/" class="post-title-link" itemprop="url">Java面试题集及参考答案</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-29 00:04:47 / 修改时间：00:26:01" itemprop="dateCreated datePublished" datetime="2019-04-29T00:04:47+08:00">2019-04-29</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h6 id="超级全面的Java面试题集及参考答案"><a href="#超级全面的Java面试题集及参考答案" class="headerlink" title="超级全面的Java面试题集及参考答案"></a>超级全面的Java面试题集及参考答案</h6><p><a href="https://blog.csdn.net/dd864140130/article/details/55833087" target="_blank" rel="noopener">https://blog.csdn.net/dd864140130/article/details/55833087</a></p>
<p>今天要谈的主题是关于求职.求职是在每个技术人员的生涯中都要经历多次,对于我们大部分人而言,在进入自己心仪的公司之前少不了准备工作,有一份全面细致面试题将帮助我们减少许多麻烦.在跳槽季来临之前,特地做这个系列的文章,一方面帮助自己巩固下基础,另一方面也希望帮助想要换工作的朋友.</p>
<p><strong>相关概念</strong><br><strong>面向对象的三个特征</strong><br>封装,继承,多态.这个应该是人人皆知.有时候也会加上抽象.<br><strong>多态的好处</strong><br>允许不同类对象对同一消息做出响应,即同一消息可以根据发送对象的不同而采用多种不同的行为方式(发送消息就是函数调用).主要有以下优点:</p>
<ol>
<li>可替换性:多态对已存在代码具有可替换性.</li>
<li>可扩充性:增加新的子类不影响已经存在的类结构.</li>
<li>接口性:多态是超类通过方法签名,向子类提供一个公共接口,由子类来完善或者重写它来实现的.</li>
<li>灵活性.</li>
<li>简化性.<br><strong>代码中如何实现多态</strong><br>实现多态主要有以下三种方式: </li>
<li><p>接口实现 </p>
</li>
<li><p>继承父类重写方法 </p>
</li>
<li><p>同一类中进行方法重载</p>
</li>
</ol>
<p><strong>虚拟机是如何实现多态的</strong><br>动态绑定技术(dynamic binding),执行期间判断所引用对象的实际类型,根据实际类型调用对应的方法.<br><strong>接口的意义</strong><br>接口的意义用三个词就可以概括:规范,扩展,回调.<br><strong>抽象类的意义</strong><br>抽象类的意义可以用三句话来概括:</p>
<ol>
<li>为其他子类提供一个公共的类型</li>
<li>封装子类中重复定义的内容</li>
<li>定义抽象方法,子类虽然有不同的实现,但是定义时一致的<br><strong>接口和抽象类的区别</strong></li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>比较</strong></th>
<th style="text-align:left"><strong>抽象类</strong></th>
<th style="text-align:left"><strong>接口</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">默认方法</td>
<td style="text-align:left">抽象类可以有默认的方法实现</td>
<td style="text-align:left">java 8之前,接口中不存在方法的实现.</td>
</tr>
<tr>
<td style="text-align:left">实现方式</td>
<td style="text-align:left">子类使用extends关键字来继承抽象类.如果子类不是抽象类,子类需要提供抽象类中所声明方法的实现.</td>
<td style="text-align:left">子类使用implements来实现接口,需要提供接口中所有声明的实现.</td>
</tr>
<tr>
<td style="text-align:left">构造器</td>
<td style="text-align:left">抽象类中可以有构造器,</td>
<td style="text-align:left">接口中不能</td>
</tr>
<tr>
<td style="text-align:left">和正常类区别</td>
<td style="text-align:left">抽象类不能被实例化</td>
<td style="text-align:left">接口则是完全不同的类型</td>
</tr>
<tr>
<td style="text-align:left">访问修饰符</td>
<td style="text-align:left">抽象方法可以有public,protected和default等修饰</td>
<td style="text-align:left">接口默认是public,不能使用其他修饰符</td>
</tr>
<tr>
<td style="text-align:left">多继承</td>
<td style="text-align:left">一个子类只能存在一个父类</td>
<td style="text-align:left">一个子类可以存在多个接口</td>
</tr>
<tr>
<td style="text-align:left">添加新方法</td>
<td style="text-align:left">想抽象类中添加新方法,可以提供默认的实现,因此可以不修改子类现有的代码</td>
<td style="text-align:left">如果往接口中添加新方法,则子类中需要实现该方法.</td>
</tr>
</tbody>
</table>
<p><strong>父类的静态方法能否被子类重写</strong><br>不能.重写只适用于实例方法,不能用于静态方法,而子类当中含有和父类相同签名的静态方法,我们一般称之为隐藏.<br><strong>什么是不可变对象</strong><br>不可变对象指对象一旦被创建，状态就不能再改变。任何修改都会创建一个新的对象，如 String、Integer及其它包装类。<br><strong>静态变量和实例变量的区别?</strong><br>静态变量存储在方法区,属于类所有.实例变量存储在堆当中,其引用存在当前线程栈.<br><strong>能否创建一个包含可变对象的不可变对象?</strong><br>当然可以创建一个包含可变对象的不可变对象的，你只需要谨慎一点，不要共享可变对象的引用就可以了，如果需要变化时，就返回原对象的一个拷贝。最常见的例子就是对象中包含一个日期对象的引用.<br><strong>java 创建对象的几种方式</strong></p>
<ol>
<li>采用new</li>
<li>通过反射</li>
<li>采用clone</li>
<li>通过序列化机制<br>前2者都需要显式地调用构造方法. 造成耦合性最高的恰好是第一种,因此你发现无论什么框架,只要涉及到解耦必先减少new的使用.<br><strong>switch中能否使用string做参数</strong><br>在idk 1.7之前,switch只能支持byte,short,char,int或者其对应的封装类以及Enum类型。从idk 1.7之后switch开始支持String.<br><strong>switch能否作用在byte,long上?</strong><br>可以用在byte上,但是不能用在long上.<br><strong>String s1=”ab”,String s2=”a”+”b”,String s3=”a”,String s4=”b”,s5=s3+s4请问s5==s2返回什么?</strong><br>返回false.在编译过程中,编译器会将s2直接优化为”ab”,会将其放置在常量池当中,s5则是被创建在堆区,相当于s5=new String(“ab”);<br><strong>你对String对象的intern()熟悉么?</strong><br>intern()方法会首先从常量池中查找是否存在该常量值,如果常量池中不存在则现在常量池中创建,如果已经存在则直接返回.<br>比如<br>String s1=”aa”;<br>String s2=s1.intern();<br>System.out.print(s1==s2);//返回true<br><strong>Object中有哪些公共方法?</strong></li>
<li>equals()</li>
<li>clone()</li>
<li>getClass()</li>
<li>notify(),notifyAll(),wait()</li>
<li>toString<br><strong>java当中的四种引用</strong><br>强引用,软引用,弱引用,虚引用.不同的引用类型主要体现在GC上:</li>
<li>强引用：如果一个对象具有强引用，它就不会被垃圾回收器回收。即使当前内存空间不足，JVM也不会回收它，而是抛出 OutOfMemoryError 错误，使程序异常终止。如果想中断强引用和某个对象之间的关联，可以显式地将引用赋值为null，这样一来的话，JVM在合适的时间就会回收该对象</li>
<li>软引用：在使用软引用时，如果内存的空间足够，软引用就能继续被使用，而不会被垃圾回收器回收，只有在内存不足时，软引用才会被垃圾回收器回收。</li>
<li>弱引用：具有弱引用的对象拥有的生命周期更短暂。因为当 JVM 进行垃圾回收，一旦发现弱引用对象，无论当前内存空间是否充足，都会将弱引用回收。不过由于垃圾回收器是一个优先级较低的线程，所以并不一定能迅速发现弱引用对象</li>
<li>虚引用：顾名思义，就是形同虚设，如果一个对象仅持有虚引用，那么它相当于没有引用，在任何时候都可能被垃圾回收器回收。</li>
</ol>
<p>更多了解参见深入对象引用：<br><a href="http://blog.csdn.net/dd864140130/article/details/49885811" target="_blank" rel="noopener">http://blog.csdn.net/dd864140130/article/details/49885811</a><br><strong>WeakReference与SoftReference的区别?</strong><br>这点在四种引用类型中已经做了解释,这里简单说明一下即可:<br>虽然 WeakReference 与 SoftReference 都有利于提高 GC 和 内存的效率，但是 WeakReference ，一旦失去最后一个强引用，就会被 GC 回收，而软引用虽然不能阻止被回收，但是可以延迟到 JVM 内存不足的时候。<br><strong>为什么要有不同的引用类型</strong><br>不像C语言,我们可以控制内存的申请和释放,在Java中有时候我们需要适当的控制对象被回收的时机,因此就诞生了不同的引用类型,可以说不同的引用类型实则是对GC回收时机不可控的妥协.有以下几个使用场景可以充分的说明:</p>
<ol>
<li>利用软引用和弱引用解决OOM问题：用一个HashMap来保存图片的路径和相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片对象所占用的空间，从而有效地避免了OOM的问题.</li>
<li><p>通过软引用实现Java对象的高速缓存:比如我们创建了一Person的类，如果每次需要查询一个人的信息,哪怕是几秒中之前刚刚查询过的，都要重新构建一个实例，这将引起大量Person对象的消耗,并且由于这些对象的生命周期相对较短,会引起多次GC影响性能。此时,通过软引用和 HashMap 的结合可以构建高速缓存,提供性能.<br><strong>java中==和**</strong>eqauls()<strong><strong>的区别,</strong></strong>equals()<strong>**和`hashcode的区别</strong><br>==是运算符,用于比较两个变量是否相等,而equals是Object类的方法,用于比较两个对象是否相等.默认Object类的equals方法是比较两个对象的地址,此时和==的结果一样.换句话说:基本类型比较用==,比较的是他们的值.默认下,对象用==比较时,比较的是内存地址,如果需要比较对象内容,需要重写equal方法<br><strong>equals()**</strong>和<strong><strong>hashcode()</strong></strong>的联系<strong><br>hashCode()是Object类的一个方法,返回一个哈希值.如果两个对象根据equal()方法比较相等,那么调用这两个对象中任意一个对象的hashCode()方法必须产生相同的哈希值.<br>如果两个对象根据eqaul()方法比较不相等,那么产生的哈希值不一定相等(碰撞的情况下还是会相等的.)
</strong>a.hashCode()有什么用?与a.equals(b)有什么关系<strong><br>hashCode() 方法是相应对象整型的 hash 值。它常用于基于 hash 的集合类，如 Hashtable、HashMap、LinkedHashMap等等。它与 equals() 方法关系特别紧密。根据 Java 规范，使用 equal() 方法来判断两个相等的对象，必须具有相同的 hashcode。<br>将对象放入到集合中时,首先判断要放入对象的hashcode是否已经在集合中存在,不存在则直接放入集合.如果hashcode相等,然后通过equal()方法判断要放入对象与集合中的任意对象是否相等:如果equal()判断不相等,直接将该元素放入集合中,否则不放入.
</strong>有没有可能两个不相等的对象有相同的hashcode<strong><br>有可能，两个不相等的对象可能会有相同的 hashcode 值，这就是为什么在 hashmap 中会有冲突。如果两个对象相等，必须有相同的hashcode 值，反之不成立.
</strong>可以在hashcode中使用随机数字吗?<strong><br>不行，因为同一对象的 hashcode 值必须是相同的
</strong>a==b与a.equals(b)有什么区别<strong><br>如果a 和b 都是对象，则 a==b 是比较两个对象的引用，只有当 a 和 b 指向的是堆中的同一个对象才会返回 true，而 a.equals(b) 是进行逻辑比较，所以通常需要重写该方法来提供逻辑一致性的比较。例如，String 类重写 equals() 方法，所以可以用于两个不同对象，但是包含的字母相同的比较。
</strong>3*0.1==0.3<strong>**返回值是什么</strong><br>false，因为有些浮点数不能完全精确的表示出来。<br><strong>a=a+b与a+=b有什么区别吗?</strong><br>+=操作符会进行隐式自动类型转换,此处a+=b隐式的将加操作的结果类型强制转换为持有结果的类型,而a=a+b则不会自动进行类型转换.如：<br>byte a = 127;<br>byte b = 127;<br>b = a + b; // error : cannot convert from int to byte<br>b += a; // ok<br>（译者注：这个地方应该表述的有误，其实无论 a+b 的值为多少，编译器都会报错，因为 a+b 操作会将 a、b 提升为 int 类型，所以将 int 类型赋值给 byte 就会编译出错）<br><strong>short s1= 1; s1 = s1 + 1; 该段代码是否有错,有的话怎么改？</strong><br>有错误,short类型在进行运算时会自动提升为int类型,也就是说s1+1的运算结果是int类型.<br><strong>short s1= 1; s1 += 1; 该段代码是否有错,有的话怎么改？</strong><br>+=操作符会自动对右边的表达式结果强转匹配左边的数据类型,所以没错.<br><strong>&amp; 和 &amp;&amp;的区别</strong><br>首先记住&amp;是位操作,而&amp;&amp;是逻辑运算符.另外需要记住逻辑运算符具有短路特性,而&amp;不具备短路特性.<br>public class Test{<br>static String name;</p>
<p>public static void main(String[] args){</p>
<pre><code>if(name!=null&amp;userName.equals(&quot;&quot;)){
    System.out.println(&quot;ok&quot;);
}else{
    System.out.println(&quot;erro&quot;);
}
</code></pre><p>}<br>}</p>
</li>
</ol>
<p>以上代码将会抛出空指针异常.<br><strong>一个.java文件内部可以有类?(非内部类)</strong><br>只能有一个public公共类,但是可以有多个default修饰的类.<br><strong>如何正确的退出多层嵌套循环.</strong></p>
<ol>
<li>使用标号和break;</li>
<li>通过在外层循环中添加标识符<br><strong>内部类的作用</strong><br>内部类可以有多个实例,每个实例都有自己的状态信息,并且与其他外围对象的信息相互独立.在单个外围类当中,可以让多个内部类以不同的方式实现同一接口,或者继承同一个类.创建内部类对象的时刻不依赖于外部类对象的创建.内部类并没有令人疑惑的”is-a”关系,它就像是一个独立的实体.<br>内部类提供了更好的封装,除了该外围类,其他类都不能访问<br><strong>final,finalize和finally的不同之处</strong><br>final 是一个修饰符，可以修饰变量、方法和类。如果 final 修饰变量，意味着该变量的值在初始化后不能被改变。finalize 方法是在对象被回收之前调用的方法，给对象自己最后一个复活的机会，但是什么时候调用 finalize 没有保证。finally 是一个关键字，与 try 和 catch 一起用于异常的处理。finally 块一定会被执行，无论在 try 块中是否有发生异常。<br><strong>clone()是哪个类的方法?</strong><br>java.lang.Cloneable 是一个标示性接口，不包含任何方法，clone 方法在 object 类中定义。并且需要知道 clone() 方法是一个本地方法，这意味着它是由 c 或 c++ 或 其他本地语言实现的。<br><strong>深拷贝和浅拷贝的区别是什么?</strong><br>浅拷贝：被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。换言之，浅拷贝仅仅复制所考虑的对象，而不复制它所引用的对象。<br>深拷贝：被复制对象的所有变量都含有与原来的对象相同的值，而那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。换言之，深拷贝把要复制的对象所引用的对象都复制了一遍。<br><strong>static都有哪些用法?</strong><br>几乎所有的人都知道static关键字这两个基本的用法:静态变量和静态方法.也就是被static所修饰的变量/方法都属于类的静态资源,类实例所共享.<br>除了静态变量和静态方法之外,static也用于静态块,多用于初始化操作:<br>public calss PreCache{<br>static{<pre><code>*//执行相关操作*
</code></pre>}<br>}</li>
</ol>
<p>此外static也多用于修饰内部类,此时称之为静态内部类.<br>最后一种用法就是静态导包,即import static.import static是在JDK 1.5之后引入的新特性,可以用来指定导入某个类中的静态资源,并且不需要使用类名.资源名,可以直接使用资源名,比如:<br>import static java.lang.Math.*;</p>
<p>public class Test{</p>
<p>   public static void main(String[] args){<br>       <em>//System.out.println(Math.sin(20));传统做法</em><br>       System.out.println(sin(20));<br>   }<br>}</p>
<p><strong>final有哪些用法</strong><br>final也是很多面试喜欢问的地方,能回答下以下三点就不错了:<br>1.被final修饰的类不可以被继承<br>2.被final修饰的方法不可以被重写<br>3.被final修饰的变量不可以被改变.如果修饰引用,那么表示引用不可变,引用指向的内容可变.<br>4.被final修饰的方法,JVM会尝试将其内联,以提高运行效率<br>5.被final修饰的常量,在编译阶段会存入常量池中.<br>回答出编译器对final域要遵守的两个重排序规则更好:<br>1.在构造函数内对一个final域的写入,与随后把这个被构造对象的引用赋值给一个引用变量,这两个操作之间不能重排序.<br>2.初次读一个包含final域的对象的引用,与随后初次读这个final域,这两个操作之间不能重排序.</p>
<p><strong>数据类型相关</strong><br><strong>java中int char,long各占多少字节?</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>类型</strong></th>
<th style="text-align:left"><strong>位数</strong></th>
<th style="text-align:left"><strong>字节数</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">short</td>
<td style="text-align:left">2</td>
<td style="text-align:left">16</td>
</tr>
<tr>
<td style="text-align:left">int</td>
<td style="text-align:left">4</td>
<td style="text-align:left">32</td>
</tr>
<tr>
<td style="text-align:left">long</td>
<td style="text-align:left">8</td>
<td style="text-align:left">64</td>
</tr>
<tr>
<td style="text-align:left">float</td>
<td style="text-align:left">4</td>
<td style="text-align:left">32</td>
</tr>
<tr>
<td style="text-align:left">double</td>
<td style="text-align:left">8</td>
<td style="text-align:left">64</td>
</tr>
<tr>
<td style="text-align:left">char</td>
<td style="text-align:left">2</td>
<td style="text-align:left">16</td>
</tr>
</tbody>
</table>
<p><strong>64位的JVM当中,int的长度是多少?</strong><br>Java 中，int 类型变量的长度是一个固定值，与平台无关，都是 32 位。意思就是说，在 32 位 和 64 位 的Java 虚拟机中，int 类型的长度是相同的。<br><strong>int和Integer的区别</strong><br>Integer是int的包装类型,在拆箱和装箱中,二者自动转换.int是基本类型，直接存数值，而integer是对象，用一个引用指向这个对象.<br><strong>int 和Integer谁占用的内存更多?</strong><br>Integer 对象会占用更多的内存。Integer是一个对象，需要存储对象的元数据。但是 int 是一个原始类型的数据，所以占用的空间更少。<br><strong>String,StringBuffer和StringBuilder区别</strong><br>String是字符串常量,final修饰;StringBuffer字符串变量(线程安全);<br>StringBuilder 字符串变量(线程不安全).<br><strong>String和StringBuffer</strong><br>String和StringBuffer主要区别是性能:String是不可变对象,每次对String类型进行操作都等同于产生了一个新的String对象,然后指向新的String对象.所以尽量不在对String进行大量的拼接操作,否则会产生很多临时对象,导致GC开始工作,影响系统性能.<br>StringBuffer是对对象本身操作,而不是产生新的对象,因此在有大量拼接的情况下,我们建议使用StringBuffer.<br>但是需要注意现在JVM会对String拼接做一定的优化:<br>String s=“This is only ”+”simple”+”test”会被虚拟机直接优化成String s=“This is only simple test”,此时就不存在拼接过程.<br><strong>StringBuffer和StringBuilder</strong><br>StringBuffer是线程安全的可变字符串,其内部实现是可变数组.StringBuilder是jdk 1.5新增的,其功能和StringBuffer类似,但是非线程安全.因此,在没有多线程问题的前提下,使用StringBuilder会取得更好的性能.<br><strong>什么是编译器常量?使用它有什么风险?</strong><br>公共静态不可变（public static final ）变量也就是我们所说的编译期常量，这里的 public 可选的。实际上这些变量在编译时会被替换掉，因为编译器知道这些变量的值，并且知道这些变量在运行时不能改变。这种方式存在的一个问题是你使用了一个内部的或第三方库中的公有编译时常量，但是这个值后面被其他人改变了，但是你的客户端仍然在使用老的值，甚至你已经部署了一个新的jar。为了避免这种情况，当你在更新依赖 JAR 文件时，确保重新编译你的程序。<br><strong>java当中使用什么类型表示价格比较好?</strong><br>如果不是特别关心内存和性能的话，使用BigDecimal，否则使用预定义精度的 double 类型。<br><strong>如何将byte转为String</strong><br>可以使用 String 接收 byte[] 参数的构造器来进行转换，需要注意的点是要使用的正确的编码，否则会使用平台默认编码，这个编码可能跟原来的编码相同，也可能不同。<br><strong>可以将int强转为byte类型么?会产生什么问题?</strong><br>我们可以做强制转换，但是Java中int是32位的而byte是8 位的，所以,如果强制转化int类型的高24位将会被丢弃，byte 类型的范围是从-128到128</p>
<p><strong>关于垃圾回收</strong><br><strong>你知道哪些垃圾回收算法?</strong><br>垃圾回收从理论上非常容易理解,具体的方法有以下几种: </p>
<ol>
<li><p>标记-清除 </p>
</li>
<li><p>标记-复制 </p>
</li>
<li><p>标记-整理 </p>
</li>
<li><p>分代回收 </p>
</li>
</ol>
<p>更详细的内容参见深入理解垃圾回收算法：<br><a href="http://blog.csdn.net/dd864140130/article/details/50084471" target="_blank" rel="noopener">http://blog.csdn.net/dd864140130/article/details/50084471</a><br><strong>如何判断一个对象是否应该被回收</strong><br>这就是所谓的对象存活性判断,常用的方法有两种:1.引用计数法;2:对象可达性分析.由于引用计数法存在互相引用导致无法进行GC的问题,所以目前JVM虚拟机多使用对象可达性分析算法.<br><strong>简单的解释一下垃圾回收</strong><br>Java 垃圾回收机制最基本的做法是分代回收。内存中的区域被划分成不同的世代，对象根据其存活的时间被保存在对应世代的区域中。一般的实现是划分成3个世代：年轻、年老和永久。内存的分配是发生在年轻世代中的。当一个对象存活时间足够长的时候，它就会被复制到年老世代中。对于不同的世代可以使用不同的垃圾回收算法。进行世代划分的出发点是对应用中对象存活时间进行研究之后得出的统计规律。一般来说，一个应用中的大部分对象的存活时间都很短。比如局部变量的存活时间就只在方法的执行过程中。基于这一点，对于年轻世代的垃圾回收算法就可以很有针对性.<br><strong>调用System.gc()会发生什么?</strong><br>通知GC开始工作,但是GC真正开始的时间不确定.</p>
<p><strong>进程,线程相关</strong><br><strong>说说进程,线程,协程之间的区别</strong><br>简而言之,进程是程序运行和资源分配的基本单位,一个程序至少有一个进程,一个进程至少有一个线程.进程在执行过程中拥有独立的内存单元,而多个线程共享内存资源,减少切换次数,从而效率更高.线程是进程的一个实体,是cpu调度和分派的基本单位,是比程序更小的能独立运行的基本单位.同一进程中的多个线程之间可以并发执行.<br><strong>你了解守护线程吗?它和非守护线程有什么区别</strong><br>程序运行完毕,jvm会等待非守护线程完成后关闭,但是jvm不会等待守护线程.守护线程最典型的例子就是GC线程<br><strong>什么是多线程上下文切换</strong><br>多线程的上下文切换是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。<br><strong>创建两种线程的方式?他们有什么区别?</strong><br>通过实现java.lang.Runnable或者通过扩展java.lang.Thread类.相比扩展Thread,实现Runnable接口可能更优.原因有二:</p>
<ol>
<li>Java不支持多继承.因此扩展Thread类就代表这个子类不能扩展其他类.而实现Runnable接口的类还可能扩展另一个类.</li>
<li>类可能只要求可执行即可,因此继承整个Thread类的开销过大.<br><strong>Thread类中的start()和run()方法有什么区别?</strong><br>start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程。<br><strong>怎么检测一个线程是否持有对象监视器</strong><br>Thread类提供了一个holdsLock(Object obj)方法，当且仅当对象obj的监视器被某条线程持有的时候才会返回true，注意这是一个static方法，这意味着”某条线程”指的是当前线程。<br><strong>Runnable和Callable的区别</strong><br>Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。<br>这其实是很有用的一个特性，因为多线程相比单线程更难、更复杂的一个重要原因就是因为多线程充满着未知性，某条线程是否执行了？某条线程执行了多久？某条线程执行的时候我们期望的数据是否已经赋值完毕？无法得知，我们能做的只是等待这条多线程的任务执行完毕而已。而Callable+Future/FutureTask却可以方便获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务<br><strong>什么导致线程阻塞</strong><br>阻塞指的是暂停一个线程的执行以等待某个条件发生（如某资源就绪），学过操作系统的同学对它一定已经很熟悉了。Java 提供了大量方法来支持阻塞，下面让我们逐一分析。</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>方法</strong></th>
<th style="text-align:left"><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">sleep()</td>
<td style="text-align:left">sleep() 允许 指定以毫秒为单位的一段时间作为参数，它使得线程在指定的时间内进入阻塞状态，不能得到CPU 时间，指定的时间一过，线程重新进入可执行状态。 典型地，sleep() 被用在等待某个资源就绪的情形：测试发现条件不满足后，让线程阻塞一段时间后重新测试，直到条件满足为止</td>
</tr>
<tr>
<td style="text-align:left">suspend() 和 resume()</td>
<td style="text-align:left">两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的resume() 被调用，才能使得线程重新进入可执行状态。典型地，suspend() 和 resume() 被用在等待另一个线程产生的结果的情形：测试发现结果还没有产生后，让线程阻塞，另一个线程产生了结果后，调用 resume() 使其恢复。</td>
</tr>
<tr>
<td style="text-align:left">yield()</td>
<td style="text-align:left">yield() 使当前线程放弃当前已经分得的CPU 时间，但不使当前线程阻塞，即线程仍处于可执行状态，随时可能再次分得 CPU 时间。调用 yield() 的效果等价于调度程序认为该线程已执行了足够的时间从而转到另一个线程</td>
</tr>
<tr>
<td style="text-align:left">wait() 和 notify()</td>
<td style="text-align:left">两个方法配套使用，wait() 使得线程进入阻塞状态，它有两种形式，一种允许 指定以毫秒为单位的一段时间作为参数，另一种没有参数，前者当对应的 notify() 被调用或者超出指定时间时线程重新进入可执行状态，后者则必须对应的 notify() 被调用.</td>
</tr>
</tbody>
</table>
<p><strong>wait(),notify()和suspend(),resume()之间的区别</strong><br>初看起来它们与 suspend() 和 resume() 方法对没有什么分别，但是事实上它们是截然不同的。区别的核心在于，前面叙述的所有方法，阻塞时都不会释放占用的锁（如果占用了的话），而这一对方法则相反。上述的核心区别导致了一系列的细节上的区别。<br>首先，前面叙述的所有方法都隶属于 Thread 类，但是这一对却直接隶属于 Object 类，也就是说，所有对象都拥有这一对方法。初看起来这十分不可思议，但是实际上却是很自然的，因为这一对方法阻塞时要释放占用的锁，而锁是任何对象都具有的，调用任意对象的 wait() 方法导致线程阻塞，并且该对象上的锁被释放。而调用 任意对象的notify()方法则导致从调用该对象的 wait() 方法而阻塞的线程中随机选择的一个解除阻塞（但要等到获得锁后才真正可执行）。<br>其次，前面叙述的所有方法都可在任何位置调用，但是这一对方法却必须在 synchronized 方法或块中调用，理由也很简单，只有在synchronized 方法或块中当前线程才占有锁，才有锁可以释放。同样的道理，调用这一对方法的对象上的锁必须为当前线程所拥有，这样才有锁可以释放。因此，这一对方法调用必须放置在这样的 synchronized 方法或块中，该方法或块的上锁对象就是调用这一对方法的对象。若不满足这一条件，则程序虽然仍能编译，但在运行时会出现IllegalMonitorStateException 异常。<br>wait() 和 notify() 方法的上述特性决定了它们经常和synchronized关键字一起使用，将它们和操作系统进程间通信机制作一个比较就会发现它们的相似性：synchronized方法或块提供了类似于操作系统原语的功能，它们的执行不会受到多线程机制的干扰，而这一对方法则相当于 block 和wakeup 原语（这一对方法均声明为 synchronized）。它们的结合使得我们可以实现操作系统上一系列精妙的进程间通信的算法（如信号量算法），并用于解决各种复杂的线程间通信问题。<br>关于 wait() 和 notify() 方法最后再说明两点：<br>第一：调用 notify() 方法导致解除阻塞的线程是从因调用该对象的 wait() 方法而阻塞的线程中随机选取的，我们无法预料哪一个线程将会被选择，所以编程时要特别小心，避免因这种不确定性而产生问题。<br>第二：除了 notify()，还有一个方法 notifyAll() 也可起到类似作用，唯一的区别在于，调用 notifyAll() 方法将把因调用该对象的 wait() 方法而阻塞的所有线程一次性全部解除阻塞。当然，只有获得锁的那一个线程才能进入可执行状态。<br>谈到阻塞，就不能不谈一谈死锁，略一分析就能发现，suspend() 方法和不指定超时期限的 wait() 方法的调用都可能产生死锁。遗憾的是，Java 并不在语言级别上支持死锁的避免，我们在编程中必须小心地避免死锁。<br>以上我们对 Java 中实现线程阻塞的各种方法作了一番分析，我们重点分析了 wait() 和 notify() 方法，因为它们的功能最强大，使用也最灵活，但是这也导致了它们的效率较低，较容易出错。实际使用中我们应该灵活使用各种方法，以便更好地达到我们的目的。<br><strong>产生死锁的条件</strong><br>1.互斥条件：一个资源每次只能被一个进程使用。<br>2.请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>3.不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。<br>4.循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。<br><strong>为什么wait()方法和notify()/notifyAll()方法要在同步块中被调用</strong><br>这是JDK强制的，wait()方法和notify()/notifyAll()方法在调用前都必须先获得对象的锁<br><strong>wait()方法和notify()/notifyAll()方法在放弃对象监视器时有什么区别</strong><br>wait()方法和notify()/notifyAll()方法在放弃对象监视器的时候的区别在于：wait()方法立即释放对象监视器，notify()/notifyAll()方法则会等待线程剩余代码执行完毕才会放弃对象监视器。<br><strong>wait()与sleep()的区别</strong><br>关于这两者已经在上面进行详细的说明,这里就做个概括好了:<br>· sleep()来自Thread类，和wait()来自Object类.调用sleep()方法的过程中，线程不会释放对象锁。而 调用 wait 方法线程会释放对象锁<br>· sleep()睡眠后不出让系统资源，wait让其他线程可以占用CPU<br>· sleep(milliseconds)需要指定一个睡眠时间，时间一到会自动唤醒.而wait()需要配合notify()或者notifyAll()使用<br><strong>为什么wait,nofity和nofityAll这些方法不放在Thread类当中</strong><br>一个很明显的原因是JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。<br><strong>怎么唤醒一个阻塞的线程</strong><br>如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。<br><strong>什么是多线程的上下文切换</strong><br>多线程的上下文切换是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。<br><strong>synchronized和ReentrantLock的区别</strong><br>synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上：<br>（1）ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁<br>（2）ReentrantLock可以获取各种锁的信息<br>（3）ReentrantLock可以灵活地实现多路通知<br>另外，二者的锁机制其实也是不一样的:ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word.<br><strong>FutureTask是什么</strong><br>这个其实前面有提到过，FutureTask表示一个异步运算的任务。FutureTask里面可以传入一个Callable的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。当然，由于FutureTask也是Runnable接口的实现类，所以FutureTask也可以放入线程池中。<br><strong>一个线程如果出现了运行时异常怎么办?</strong><br>如果这个异常没有被捕获的话，这个线程就停止执行了。另外重要的一点是：如果这个线程持有某个某个对象的监视器，那么这个对象监视器会被立即释放<br><strong>Java当中有哪几种锁</strong></p>
<ol>
<li>自旋锁: 自旋锁在JDK1.6之后就默认开启了。基于之前的观察，共享数据的锁定状态只会持续很短的时间，为了这一小段时间而去挂起和恢复线程有点浪费，所以这里就做了一个处理，让后面请求锁的那个线程在稍等一会，但是不放弃处理器的执行时间，看看持有锁的线程能否快速释放。为了让线程等待，所以需要让线程执行一个忙循环也就是自旋操作。在jdk6之后，引入了自适应的自旋锁，也就是等待的时间不再固定了，而是由上一次在同一个锁上的自旋时间及锁的拥有者状态来决定</li>
<li>偏向锁: 在JDK1.之后引入的一项锁优化，目的是消除数据在无竞争情况下的同步原语。进一步提升程序的运行性能。 偏向锁就是偏心的偏，意思是这个锁会偏向第一个获得他的线程，如果接下来的执行过程中，改锁没有被其他线程获取，则持有偏向锁的线程将永远不需要再进行同步。偏向锁可以提高带有同步但无竞争的程序性能，也就是说他并不一定总是对程序运行有利，如果程序中大多数的锁都是被多个不同的线程访问，那偏向模式就是多余的，在具体问题具体分析的前提下，可以考虑是否使用偏向锁。</li>
<li>轻量级锁: 为了减少获得锁和释放锁所带来的性能消耗，引入了“偏向锁”和“轻量级锁”，所以在Java SE1.6里锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁<br><strong>如何在两个线程间共享数据</strong><br>通过在线程之间共享对象就可以了，然后通过wait/notify/notifyAll、await/signal/signalAll进行唤起和等待，比方说阻塞队列BlockingQueue就是为线程之间共享数据而设计的<br><strong>如何正确的使用wait()?使用if还是while?</strong><br>wait() 方法应该在循环调用，因为当线程获取到 CPU 开始执行的时候，其他条件可能还没有满足，所以在处理前，循环检测条件是否满足会更好。下面是一段标准的使用 wait 和 notify 方法的代码：<br>synchronized (obj) {<br>while (condition does not hold)<br>  obj.wait(); <em>// (Releases lock, and reacquires on wakeup)</em><br>  … <em>// Perform action appropriate to condition</em><br>}</li>
</ol>
<p><strong>什么是线程局部变量ThreadLocal</strong><br>线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。<br><strong>ThreadLoal的作用是什么?</strong><br>简单说ThreadLocal就是一种以空间换时间的做法在每个Thread里面维护了一个ThreadLocal.ThreadLocalMap把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了.<br><strong>生产者消费者模型的作用是什么?</strong><br>（1）通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率，这是生产者消费者模型最重要的作用<br>（2）解耦，这是生产者消费者模型附带的作用，解耦意味着生产者和消费者之间的联系少，联系越少越可以独自发展而不需要收到相互的制约<br><strong>写一个生产者-消费者队列</strong><br>可以通过阻塞队列实现,也可以通过wait-notify来实现.<br><strong>使用阻塞队列来实现</strong><br><em>//消费者</em><br>public class Producer implements Runnable{<br>   private final BlockingQueue<integer> queue;</integer></p>
<p>   public Producer(BlockingQueue q){<br>       this.queue=q;<br>   }</p>
<p>   @Override<br>   public void run() {<br>       try {<br>           while (true){<br>               Thread.sleep(1000);<em>//模拟耗时</em><br>               queue.put(produce());<br>           }<br>       }catch (InterruptedException e){</p>
<pre><code>}
</code></pre><p>   }</p>
<p>   private int produce() {<br>       int n=new Random().nextInt(10000);<br>       System.out.println(“Thread:” + Thread.currentThread().getId() + “ produce:” + n);<br>       return n;<br>   }<br>}<br><em>//消费者</em><br>public class Consumer implements Runnable {<br>   private final BlockingQueue<integer> queue;</integer></p>
<p>   public Consumer(BlockingQueue q){<br>       this.queue=q;<br>   }</p>
<p>   @Override<br>   public void run() {<br>       while (true){<br>           try {<br>               Thread.sleep(2000);<em>//模拟耗时</em><br>               consume(queue.take());<br>           }catch (InterruptedException e){</p>
<pre><code>    }

}
</code></pre><p>   }</p>
<p>   private void consume(Integer n) {<br>       System.out.println(“Thread:” + Thread.currentThread().getId() + “ consume:” + n);</p>
<p>   }<br>}<br><em>//测试</em><br>public class Main {</p>
<p>   public static void main(String[] args) {<br>       BlockingQueue<integer> queue=new ArrayBlockingQueue<integer>(100);<br>       Producer p=new Producer(queue);<br>       Consumer c1=new Consumer(queue);<br>       Consumer c2=new Consumer(queue);</integer></integer></p>
<pre><code>new Thread(p).start();
new Thread(c1).start();
new Thread(c2).start();
</code></pre><p>   }<br>}</p>
<p><strong>使用wait-notify来实现</strong><br>该种方式应该最经典,这里就不做说明了<br><strong>如果你提交任务时，线程池队列已满，这时会发生什么</strong><br>如果你使用的LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为LinkedBlockingQueue可以近乎认为是一个无穷大的队列，可以无限存放任务；如果你使用的是有界队列比方说ArrayBlockingQueue的话，任务首先会被添加到ArrayBlockingQueue中，ArrayBlockingQueue满了，则会使用拒绝策略RejectedExecutionHandler处理满了的任务，默认是AbortPolicy。<br><strong>为什么要使用线程池</strong><br>避免频繁地创建和销毁线程，达到线程对象的重用。另外，使用线程池还可以根据项目灵活地控制并发的数目。<br><strong>java中用到的线程调度算法是什么</strong><br>抢占式。一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。<br><strong>Thread.sleep(0)的作用是什么</strong><br>由于Java采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到CPU控制权的情况，为了让某些优先级比较低的线程也能获取到CPU控制权，可以使用Thread.sleep(0)手动触发一次操作系统分配时间片的操作，这也是平衡CPU控制权的一种操作。<br><strong>什么是CAS</strong><br>CAS，全称为Compare and Swap，即比较-替换。假设有三个操作数：内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，才会将内存值修改为B并返回true，否则什么都不做并返回false。当然CAS一定要volatile变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值，否则旧的预期值A对某条线程来说，永远是一个不会变的值A，只要某次CAS操作失败，永远都不可能成功<br><strong>什么是乐观锁和悲观锁</strong><br>乐观锁：乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。<br>悲观锁：悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。<br><strong>ConcurrentHashMap的并发度是什么?</strong><br>ConcurrentHashMap的并发度就是segment的大小，默认为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这也是ConcurrentHashMap对Hashtable的最大优势，任何情况下，Hashtable能同时有两条线程获取Hashtable中的数据吗？<br><strong>ConcurrentHashMap的工作原理</strong><br>ConcurrentHashMap在jdk 1.6和jdk 1.8实现原理是不同的.<br><strong>jdk 1.6:</strong><br>ConcurrentHashMap是线程安全的，但是与Hashtablea相比，实现线程安全的方式不同。Hashtable是通过对hash表结构进行锁定，是阻塞式的，当一个线程占有这个锁时，其他线程必须阻塞等待其释放锁。ConcurrentHashMap是采用分离锁的方式，它并没有对整个hash表进行锁定，而是局部锁定，也就是说当一个线程占有这个局部锁时，不影响其他线程对hash表其他地方的访问。<br>具体实现:ConcurrentHashMap内部有一个Segment<br><strong>jdk 1.8</strong><br>在jdk 8中，ConcurrentHashMap不再使用Segment分离锁，而是采用一种乐观锁CAS算法来实现同步问题，但其底层还是“数组+链表-&gt;红黑树”的实现。<br><strong>CyclicBarrier和CountDownLatch区别</strong><br>这两个类非常类似，都在java.util.concurrent下，都可以用来表示代码运行到某个点上，二者的区别在于：<br>· CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值-1而已，该线程继续运行<br>· CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务<br>· CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了<br><strong>java中的++操作符线程安全么?</strong><br>不是线程安全的操作。它涉及到多个指令，如读取变量值，增加，然后存储回内存，这个过程可能会出现多个线程交差<br><strong>你有哪些多线程开发良好的实践?</strong></p>
<ol>
<li>给线程命名</li>
<li>最小化同步范围</li>
<li>优先使用volatile</li>
<li>尽可能使用更高层次的并发工具而非wait和notify()来实现线程通信,如BlockingQueue,Semeaphore</li>
<li>优先使用并发容器而非同步容器.</li>
<li>考虑使用线程池</li>
</ol>
<p><strong>关于volatile关键字</strong><br><strong>可以创建Volatile数组吗?</strong><br>Java 中可以创建 volatile类型数组，不过只是一个指向数组的引用，而不是整个数组。如果改变引用指向的数组，将会受到volatile 的保护，但是如果多个线程同时改变数组的元素，volatile标示符就不能起到之前的保护作用了<br><strong>volatile能使得一个非原子操作变成原子操作吗?</strong><br>一个典型的例子是在类中有一个 long 类型的成员变量。如果你知道该成员变量会被多个线程访问，如计数器、价格等，你最好是将其设置为 volatile。为什么？因为 Java 中读取 long 类型变量不是原子的，需要分成两步，如果一个线程正在修改该 long 变量的值，另一个线程可能只能看到该值的一半（前 32 位）。但是对一个 volatile 型的 long 或 double 变量的读写是原子。<br>一种实践是用 volatile 修饰 long 和 double 变量，使其能按原子类型来读写。double 和 long 都是64位宽，因此对这两种类型的读是分为两部分的，第一次读取第一个 32 位，然后再读剩下的 32 位，这个过程不是原子的，但 Java 中 volatile 型的 long 或 double 变量的读写是原子的。volatile 修复符的另一个作用是提供内存屏障（memory barrier），例如在分布式框架中的应用。简单的说，就是当你写一个 volatile 变量之前，Java 内存模型会插入一个写屏障（write barrier），读一个 volatile 变量之前，会插入一个读屏障（read barrier）。意思就是说，在你写一个 volatile 域时，能保证任何线程都能看到你写的值，同时，在写之前，也能保证任何数值的更新对所有线程是可见的，因为内存屏障会将其他所有写的值更新到缓存。<br><strong>volatile类型变量提供什么保证?</strong><br>volatile 主要有两方面的作用:1.避免指令重排2.可见性保证.例如，JVM 或者 JIT为了获得更好的性能会对语句重排序，但是 volatile 类型变量即使在没有同步块的情况下赋值也不会与其他语句重排序。 volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。某些情况下，volatile 还能提供原子性，如读 64 位数据类型，像 long 和 double 都不是原子的(低32位和高32位)，但 volatile 类型的 double 和 long 就是原子的.</p>
<p><strong>关于集合</strong><br><strong>Java中的集合及其继承关系</strong><br>关于集合的体系是每个人都应该烂熟于心的,尤其是对我们经常使用的List,Map的原理更该如此.这里我们看这张图即可:<br><img src="https://shimo.im/fake.png" alt="图片"><br>更多内容可见集合类总结：<br><a href="http://write.blog.csdn.net/postedit/40826423" target="_blank" rel="noopener">http://write.blog.csdn.net/postedit/40826423</a><br><strong>poll()方法和remove()方法区别?</strong><br>poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。<br><strong>LinkedHashMap和PriorityQueue的区别</strong><br>PriorityQueue 是一个优先级队列,保证最高或者最低优先级的的元素总是在队列头部，但是 LinkedHashMap 维持的顺序是元素插入的顺序。当遍历一个 PriorityQueue 时，没有任何顺序保证，但是 LinkedHashMap 课保证遍历顺序是元素插入的顺序。<br><strong>WeakHashMap与HashMap的区别是什么?</strong><br>WeakHashMap 的工作与正常的 HashMap 类似，但是使用弱引用作为 key，意思就是当 key 对象没有任何引用时，key/value 将会被回收。<br><strong>ArrayList和LinkedList的区别?</strong><br>最明显的区别是 ArrrayList底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构是双向循环链表，不支持随机访问。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。<br><strong>ArrayList和Array有什么区别?</strong></p>
<ol>
<li>Array可以容纳基本类型和对象，而ArrayList只能容纳对象。</li>
<li>Array是指定大小的，而ArrayList大小是固定的<br><strong>ArrayList和HashMap默认大小?</strong><br>在 Java 7 中，ArrayList 的默认大小是 10 个元素，HashMap 的默认大小是16个元素（必须是2的幂）。这就是 Java 7 中 ArrayList 和 HashMap 类的代码片段<br>private static final int DEFAULT_CAPACITY = 10;</li>
</ol>
<p><em>//from HashMap.java JDK 7</em><br>static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; <em>// aka 16</em></p>
<p><strong>Comparator和Comparable的区别?</strong><br>Comparable 接口用于定义对象的自然顺序，而 comparator 通常用于定义用户定制的顺序。Comparable 总是只有一个，但是可以有多个 comparator 来定义对象的顺序。<br><strong>如何实现集合排序?</strong><br>你可以使用有序集合，如 TreeSet 或 TreeMap，你也可以使用有顺序的的集合，如 list，然后通过 Collections.sort() 来排序。<br><strong>如何打印数组内容</strong><br>你可以使用 Arrays.toString() 和 Arrays.deepToString() 方法来打印数组。由于数组没有实现 toString() 方法，所以如果将数组传递给 System.out.println() 方法，将无法打印出数组的内容，但是 Arrays.toString() 可以打印每个元素。<br><strong>LinkedList的是单向链表还是双向?</strong><br>双向循环列表,具体实现自行查阅源码.<br><strong>TreeMap是实现原理</strong><br>采用红黑树实现,具体实现自行查阅源码.<br><strong>遍历ArrayList时如何正确移除一个元素</strong><br>该问题的关键在于面试者使用的是 ArrayList 的 remove() 还是 Iterator 的 remove()方法。这有一段示例代码，是使用正确的方式来实现在遍历的过程中移除元素，而不会出现 ConcurrentModificationException 异常的示例代码。<br><strong>什么是ArrayMap?它和HashMap有什么区别?</strong><br>ArrayMap是Android SDK中提供的,非Android开发者可以略过.<br>ArrayMap是用两个数组来模拟map,更少的内存占用空间,更高的效率.<br>具体参考这篇文章:ArrayMap VS HashMap：<a href="http://lvable.com/?p=217%5D" target="_blank" rel="noopener">http://lvable.com/?p=217%5D</a><br><strong>HashMap的实现原理</strong><br>1 HashMap概述： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。<br>2 HashMap的数据结构： 在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。<br>当我们往Hashmap中put元素时,首先根据key的hashcode重新计算hash值,根绝hash值得到这个元素在数组中的位置(下标),如果该数组在该位置上已经存放了其他元素,那么在这个位置上的元素将以链表的形式存放,新加入的放在链头,最先加入的放入链尾.如果数组中该位置没有元素,就直接将该元素放到数组的该位置上.<br>需要注意Jdk 1.8中对HashMap的实现做了优化,当链表中的节点数据超过八个之后,该链表会转为红黑树来提高查询效率,从原来的O(n)到O(logn)<br><strong>你了解Fail-Fast机制吗</strong><br>Fail-Fast即我们常说的快速失败,<br>更多内容参看fail-fast机制：<a href="http://blog.csdn.net/chenssy/article/details/38151189" target="_blank" rel="noopener">http://blog.csdn.net/chenssy/article/details/38151189</a><br><strong>Fail-fast和Fail-safe有什么区别</strong><br>Iterator的fail-fast属性与当前的集合共同起作用，因此它不会受到集合中任何改动的影响。Java.util包中的所有集合类都被设计为fail-&gt;fast的，而java.util.concurrent中的集合类都为fail-safe的。当检测到正在遍历的集合的结构被改变时，Fail-fast迭代器抛出ConcurrentModificationException，而fail-safe迭代器从不抛出ConcurrentModificationException。</p>
<p><strong>关于日期</strong><br><strong>SimpleDateFormat是线程安全的吗?</strong><br>非常不幸，DateFormat 的所有实现，包括 SimpleDateFormat 都不是线程安全的，因此你不应该在多线程序中使用，除非是在对外线程安全的环境中使用，如 将 SimpleDateFormat 限制在 ThreadLocal 中。如果你不这么做，在解析或者格式化日期的时候，可能会获取到一个不正确的结果。因此，从日期、时间处理的所有实践来说，我强力推荐 joda-time 库。<br><strong>如何格式化日期?</strong><br>Java 中，可以使用 SimpleDateFormat 类或者 joda-time 库来格式日期。DateFormat 类允许你使用多种流行的格式来格式化日期。参见答案中的示例代码，代码中演示了将日期格式化成不同的格式，如 dd-MM-yyyy 或 ddMMyyyy。</p>
<p><strong>关于异常</strong><br><strong>简单描述java异常体系</strong><br>相比没有人不了解异常体系,关于异常体系的更多信息可以见<br>白话异常机制：<a href="http://blog.csdn.net/dd864140130/article/details/42504189" target="_blank" rel="noopener">http://blog.csdn.net/dd864140130/article/details/42504189</a><br><strong>什么是异常链</strong><br>详情直接参见上面的白话异常机制,不做解释了.<br><strong>throw和throws的区别</strong><br>throw用于主动抛出java.lang.Throwable 类的一个实例化对象，意思是说你可以通过关键字 throw 抛出一个 Error 或者 一个Exception，如：throw new IllegalArgumentException(“size must be multiple of 2″),<br>而throws 的作用是作为方法声明和签名的一部分，方法被抛出相应的异常以便调用者能处理。Java 中，任何未处理的受检查异常强制在 throws 子句中声明。</p>
<p><strong>关于序列化</strong><br><strong>Java 中，Serializable 与 Externalizable 的区别</strong><br>Serializable 接口是一个序列化 Java 类的接口，以便于它们可以在网络上传输或者可以将它们的状态保存在磁盘上，是 JVM 内嵌的默认序列化方式，成本高、脆弱而且不安全。Externalizable 允许你控制整个序列化过程，指定特定的二进制格式，增加安全机制。</p>
<p><strong>关于JVM</strong><br><strong>JVM特性</strong><br>平台无关性.<br>Java语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用模式Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。<br><strong>简单解释一下类加载器</strong><br>有关类加载器一般会问你四种类加载器的应用场景以及双亲委派模型,<br>更多的内容参看深入理解JVM加载器：<br><a href="http://blog.csdn.net/dd864140130/article/details/49817357" target="_blank" rel="noopener">http://blog.csdn.net/dd864140130/article/details/49817357</a><br><strong>简述堆和栈的区别</strong><br>VM 中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。<br><strong>简述JVM内存分配</strong></p>
<ol>
<li>基本数据类型比变量和对象的引用都是在栈分配的</li>
<li>堆内存用来存放由new创建的对象和数组</li>
<li>类变量（static修饰的变量），程序在一加载的时候就在堆中为类变量分配内存，堆中的内存地址存放在栈中</li>
<li>实例变量：当你使用java关键字new的时候，系统在堆中开辟并不一定是连续的空间分配给变量，是根据零散的堆内存地址，通过哈希算法换算为一长串数字以表征这个变量在堆中的”物理位置”,实例变量的生命周期–当实例变量的引用丢失后，将被GC（垃圾回收器）列入可回收“名单”中，但并不是马上就释放堆中内存</li>
<li>局部变量: 由声明在某方法，或某代码段里（比如for循环），执行到它的时候在栈中开辟内存，当局部变量一但脱离作用域，内存立即释放</li>
</ol>
<p><strong>其他</strong><br><strong>java当中采用的是大端还是小端?</strong><br><strong>XML解析的几种方式和特点</strong><br>DOM,SAX,PULL三种解析方式:<br>· DOM:消耗内存：先把xml文档都读到内存中，然后再用DOM API来访问树形结构，并获取数据。这个写起来很简单，但是很消耗内存。要是数据过大，手机不够牛逼，可能手机直接死机<br>· SAX:解析效率高，占用内存少，基于事件驱动的：更加简单地说就是对文档进行顺序扫描，当扫描到文档(document)开始与结束、元素(element)开始与结束、文档(document)结束等地方时通知事件处理函数，由事件处理函数做相应动作，然后继续同样的扫描，直至文档结束。<br>· PULL:与 SAX 类似，也是基于事件驱动，我们可以调用它的next（）方法，来获取下一个解析事件（就是开始文档，结束文档，开始标签，结束标签），当处于某个元素时可以调用XmlPullParser的getAttributte()方法来获取属性的值，也可调用它的nextText()获取本节点的值。<br><strong>JDK 1.7特性</strong><br>然 JDK 1.7 不像 JDK 5 和 8 一样的大版本，但是，还是有很多新的特性，如 try-with-resource 语句，这样你在使用流或者资源的时候，就不需要手动关闭，Java 会自动关闭。Fork-Join 池某种程度上实现 Java 版的 Map-reduce。允许 Switch 中有 String 变量和文本。菱形操作符(&lt;&gt;)用于类型推断，不再需要在变量声明的右边申明泛型，因此可以写出可读写更强、更简洁的代码<br><strong>JDK 1.8特性</strong><br>java 8 在 Java 历史上是一个开创新的版本，下面 JDK 8 中 5 个主要的特性：<br>Lambda 表达式，允许像对象一样传递匿名函数<br>Stream API，充分利用现代多核 CPU，可以写出很简洁的代码<br>Date 与 Time API，最终，有一个稳定、简单的日期和时间库可供你使用<br>扩展方法，现在，接口中可以有静态、默认方法。<br>重复注解，现在你可以将相同的注解在同一类型上使用多次。<br><strong>Maven和ANT有什么区别?</strong><br>虽然两者都是构建工具，都用于创建 Java 应用，但是 Maven 做的事情更多，在基于“约定优于配置”的概念下，提供标准的Java 项目结构，同时能为应用自动管理依赖（应用中所依赖的 JAR 文件.<br><strong>JDBC最佳实践</strong><br>· 优先使用批量操作来插入和更新数据<br>· 使用PreparedStatement来避免SQL漏洞<br>· 使用数据连接池<br>· 通过列名来获取结果集<br><strong>IO操作最佳实践</strong><br>· 使用有缓冲的IO类,不要单独读取字节或字符<br>· 使用NIO和NIO 2或者AIO,而非BIO<br>· 在finally中关闭流<br>· 使用内存映射文件获取更快的IO</p>
<p><strong>好的东西要和朋友一起分享，赶快将本文分享给你身边正在准备Java面试的朋友吧！</strong></p>
<p>●编号684，输入编号直达本文<br>●输入m获取文章目录<br><strong>推荐↓↓↓</strong><br><img src="https://shimo.im/fake.png" alt="图片"><br><strong>Python编程</strong><br><strong>更多推荐：《</strong><a href="http://#wechat_redirect" target="_blank" rel="noopener">18个技术类微信公众号</a><strong>》</strong><br>涵盖：程序人生、算法与数据结构、黑客技术与网络安全、大数据技术、前端开发、Java、Python、Web开发、安卓开发、iOS开发、C/C++、.NET、Linux、数据库、运维等。<br><a href="http://##" target="_blank" rel="noopener">阅读原文</a><br><img src="https://shimo.im/fake.png" alt="图片"><br>微信扫一扫<br>关注该公众号</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://Syq777.github.io/2019/04/29/面试/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Syq">
      <meta itemprop="description" content="寻门而入，破门而出。">
      <meta itemprop="image" content="/images/image.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/29/面试/" class="post-title-link" itemprop="url">面试</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-29 00:03:32 / 修改时间：00:13:13" itemprop="dateCreated datePublished" datetime="2019-04-29T00:03:32+08:00">2019-04-29</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/面试/" itemprop="url" rel="index"><span itemprop="name">面试</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h6 id="面试总结-子元哥"><a href="#面试总结-子元哥" class="headerlink" title="面试总结(子元哥)"></a>面试总结(子元哥)</h6><p>自己做的模板<br>经验项目<br>不要说培训经历，项目<br>合作<br>住的<br>大公司实习<br>培训几个月干活的不要去<br>4000<br>se  数据库  算法  排序 数据结构<br>框架<br>不要太急<br>两轮面试</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://Syq777.github.io/2019/04/28/大数据云计算虚拟化概念区分/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Syq">
      <meta itemprop="description" content="寻门而入，破门而出。">
      <meta itemprop="image" content="/images/image.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/28/大数据云计算虚拟化概念区分/" class="post-title-link" itemprop="url">大数据云计算虚拟化概念区分</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-28 23:59:10" itemprop="dateCreated datePublished" datetime="2019-04-28T23:59:10+08:00">2019-04-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-29 00:25:54" itemprop="dateModified" datetime="2019-04-29T00:25:54+08:00">2019-04-29</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/概念/" itemprop="url" rel="index"><span itemprop="name">概念</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h6 id="云计算是什么"><a href="#云计算是什么" class="headerlink" title="云计算是什么"></a>云计算是什么</h6><p>官方解释：云计算是一种按使用量付费的模式，这种模式提供可用的、便捷的、按需的网络访问， 进入可配置的计算资源共享池（资源包括网络，服务器，存储，应用软件，服务），这些资源能够被快速提供，只需投入很少的管理工作，或与服务供应商进行很少的交互。</p>
<p>我们应该如何通俗地理解：<br>首先按照传统方式建立网站，要怎么做呢？需要购买服务器，网络带宽，注册网站域名，开发，运维等一系列复杂的过程，最后才能建立起来我的网站。就好像是我们想要获得干净的水源，前期需要购置很多工具，花费大量人力，最后才能打出来一口井。</p>
<p>云计算是什么？通俗理解就是有一个云厂商已经建立好了自来水井，也铺好了自来水管道，我们直接拿被子取干净的水就好了，这就是一套自来水系统。不用再去打水井，铺管道，提高了时间效率，也大大降低了人力成本。</p>
<p>云计算是如何分类的<br>云计算一般分为三类：基础架构即服务（IaaS）、平台即服务（PaaP）和软件即服务（SaaS）</p>
<p>基础架构即服务（IaaS）<br>也就是基础设施服务，主要是通过网络的方式向用户提供计算，储存，网络等基础资源。目前中小型企业或用户都是购买这类基础性框架服务。通俗理解就是从水厂的水源，厂房，自来水管道，这类属于最基础的设施。</p>
<p>平台即服务（PaaP）<br>主要是通过平台向用户提供应用软件的开发，测试，快速部署，帮助用户快速实现更多应用功能。主要针对互联网公司，比较成型规模的公司。通俗理解就是为了达到特定的目的而提供的工具，如过滤的工具，增加矿物质的工具，增加二氧化碳含量的工具，也就是为这个自来水持续地增加它的价值。</p>
<p>软件即服务（SaaS）<br>直接加工成商品性的东西去卖就好了，通俗理解就是直接获得自来水，将水再加工处理，做成特定的产品卖出去，如纯净水，苏打水，农夫山泉，怡宝等这类产品。</p>
<hr>
<ol>
<li>虚拟化及分类</li>
</ol>
<p>虚拟化是指计算机元件在虚拟的基础上而不是真实的基础上运行。虚拟化技术可以扩大硬件的容量，简化软件的重新配置过程。CPU的虚拟化技术可以单CPU模拟多CPU并行，允许一个平台同时运行多个操作系统，并且应用程序都可以在相互独立的空间内运行而互不影响，从而显著提高计算机的工作效率。</p>
<p>  顾名思义，虚拟化就是在计算上虚拟出一些实际计算机里真实存在的东西，以达到更方便、简单、成本低、安全性高的目的。比如，虚拟计算机硬件，可以安装操作系统;以现有操作系统为蓝本，再虚拟出几个一摸一样的;虚拟一个操作系统环境，可以安装应用软件。这个解释，是本人很通俗的说法，严格精准的定义，至今还未看到。</p>
<p>　</p>
<p>1.1 以实现层次来分：硬件虚拟化，操作系统虚拟化，应用程序虚拟化。<br>    言归正传，现在按照不同属性，对虚拟化做一个分类：<br>    以被应用的领域来划分：服务器虚拟化、存储虚拟化、网络虚拟化、桌面虚拟化。<br>  还有从以某类里衍生出来的，无法归类，比如cpu虚拟化，文件虚拟化。<br>  这些不用属性的类别之间的关系又是交错联系的，下面逐一简单介绍一下。</p>
<p>1.1.1 硬件虚拟化<br>  硬件虚拟化，就是用软件来虚拟一台标准电脑的硬件配置，如cpu、内存、硬盘、声显卡、光驱等，成为一台虚拟的裸机，然后就可以在上面安装操作系统了，其代表产品VMware。</p>
<p>  使用时，先在操作系统里安装一个硬件虚拟化软件，用其虚拟出一台电脑，再安装系统，做到系统里运行系统，并可虚拟出多台电脑，安装多个相同或不同的系统。</p>
<p>  其代表产品为VMware，其余几个知名的有：微软的Virtual PC，开源免费的VirtualBox。</p>
<p>  为虚拟机分配的硬件资源要占用实际硬件的资源，对性能损耗也较大。因为是在系统里安装虚拟化软件，再在虚拟的电脑上装系统，所以就有原系统和虚拟化软件两层消耗，为了提高性能，出现了另外一种硬件虚拟化形式：直接在裸机上安装虚拟化软件，然后安装多个系统，并同时运行。跳过原系统这一环节，性能大大提高。这种虚拟化又叫做准虚拟化。VMware推出的相关产品叫VMware ESXi，微软的该类产品为Hyper-V，主要应用于服务器领域。</p>
<p>1.1.2  操作系统虚拟化（OS-level virtualization）<br>  操作系统虚拟化就是以一个系统为母体，克隆出多个系统。它比硬件虚拟化要灵活方便，因为只需在系统里装一个虚拟化软件，就能以原系统为样本，很快克隆出系统，克隆出的系统与原系统除去一些ID标识外，其余都一样。</p>
<p>  看似与硬件虚拟化一样，都是虚拟多个操作系统出来，但与硬件虚拟化还是很多不同之处：</p>
<ol>
<li><p>操作系统虚拟化是以原系统为样本，虚拟出一个近乎一摸一样的系统;硬件虚拟化是虚拟硬件环境，然后真实的安装系统。它们虚拟的东西不一样。</p>
</li>
<li><p>操作系统虚拟化，虚拟的系统都只能为同样的系统;硬件虚拟化，虚拟的系统可以为不同的系统，如linnux、mac、windows家族。</p>
</li>
<li><p>操作系统虚拟化，虚拟的多个系统有较强的联系，体现在：第一，可以多个虚拟系统同时进行配置，更改了原系统，就改了所有;第二，如果原系统损坏，会殃及所有虚拟系统。硬件虚拟化虚拟的多个系统，是相互独立，与原系统也无联系。原系统的损坏不会殃及虚拟的系统。</p>
</li>
<li><p>操作系统虚拟化的性能损耗低，它们都是虚拟的系统，而非硬件虚拟化那样真实安装的实体;没有硬件虚拟化的虚拟硬件层，也大大降低了性能损耗。</p>
</li>
</ol>
<p>这种方式由FreeBSD jails首创；类似的例子包括Solaris Containers， OpenVZ， Linux-VServer， AIX Workload Partitions， Parallels Virtuozzo Containers， 以及 iCore Virtual Accounts。</p>
<p>1.1.3 应用虚拟化<br>  前两种虚拟化技术，大多应用于企业、服务器和一些IT专业工作领域。随着虚拟化技术的发展，逐渐从企业往个人、专业往大众应用的趋势发展，便出现了应用程序虚拟化技术，简称应用虚拟化。它近年虚拟化的新贵和热门领域。</p>
<p>  前两种虚拟化的目的是虚拟完整的真实的操作系统，应用虚拟化的目的也是虚拟操作系统，但只是为保证应用程序的正常运行虚拟系统的某些关键部分，如注册表、C盘环境等，所以较为轻量、小巧。</p>
<p>1.2 根据虚拟化程度分为：软件全虚拟化、软件半虚拟化和硬件辅助虚拟化<br>    纯软件的“全虚拟化”方式不需要修改客户机操作系统，但是其性能较未虚拟化时影响比较大。支持完全虚拟化的虚拟机软件包括VMware Workstation和Virtual PC等。</p>
<pre><code>半虚拟化模式，这种模式需要对客户机操作系统进行更改，使得客户机操作系统知道其运行在虚拟化环境下，从而可以获得更高的性能。半虚拟化的典型产品包括Xen、UML等。



看虚拟化技术是完全虚拟化还是半虚拟化，首先看虚拟化技术有没有修改内核，xen虚拟化技术需要修改内核，因此它有完全虚拟化和半虚拟化之分，kvm没有修改内核，因此，它只有完全虚拟化；还要看cpu是否支持硬件虚拟化，支持硬件虚拟化，就是完全虚拟化，不支持，就是半虚拟化。xen有两种选择，而kvm只有一种选择，所以，xen有完全虚拟化和半虚拟化之分，kvm只有完全虚拟化。



硬件辅助虚拟化技术，在处理器中加入了新的特权级来运行虚拟机监控层，使得客户机操作系统可以运行在原始特权级，不需要更改，并且由硬件来完成两个特权级之间的转换。硬件辅助虚拟技术提高了虚拟机的兼容性和性能。支持硬件辅助虚拟化的有 Linux KVM和Xen等。
</code></pre><p>1.3 按照虚拟层次分为：分为程序级虚拟化和系统级虚拟化<br>  前者通常是在应用层上创建虚拟机，这种虚拟机通常是为了运行应用程序而创建，并且随着应用程序的退出而结束。应用级虚拟机的一个典型例子就是Java虚拟机（JVM）。<br>系统级虚拟化包括一个Hypervisor或者VMM（Virtual Machine Monitor）。Hypervisor是位于硬件资源和操作系统之间的软件层。它使得多个单独的虚拟机实例可以同时运行，并使得多个虚拟机可以共享各种物理硬件资源。Hypervisor协调这些硬件资源（CPU、内存和各种I/O设备）的访问，为虚拟机分配各种需要使用的资源。</p>
<p>   对于系统级虚拟化，根据虚拟机监视器 Hypervisor或VMM的实现层次，主要可以分为基于宿主操作系统的系统级虚拟化和基于硬件的系统级虚拟化。</p>
<p>基于宿主操作系统的虚拟机作为应用程序运行在宿主操作系统（Host OS）之上，其架构如图1 所示。因此Guest VM需要由Guest Os内核先经过Hypervisor，再经过宿主操作系统才能访问硬件。支持基于宿主操作系统虚拟化的产品有 Virtual PC、VMWare Workstation和VirtualBox等。</p>
<p>Docker的思想来自于集装箱，集装箱解决了什么问题？在一艘大船上，可以把货物规整的摆放起来。并且各种各样的货物被集装箱标准化了，集装箱和集装箱之间不会互相影响。那么我就不需要专门运送水果的船和专门运送化学品的船了。只要这些货物在集装箱里封装的好好的，那我就可以用一艘大船把他们都运走。docker就是类似的理念。现在都流行云计算了，云计算就好比大货轮。docker就是集装箱。1.不同的应用程序可能会有不同的应用环境，比如.net开发的网站和php开发的网站依赖的软件就不一样，如果把他们依赖的软件都安装在一个服务器上就要调试很久，而且很麻烦，还会造成一些冲突。比如IIS和Apache访问端口冲突。这个时候你就要隔离.net开发的网站和php开发的网站。常规来讲，我们可以在服务器上创建不同的虚拟机在不同的虚拟机上放置不同的应用，但是虚拟机开销比较高。docker可以实现虚拟机隔离应用环境的功能，并且开销比虚拟机小，小就意味着省钱了。2.你开发软件的时候用的是Ubuntu，但是运维管理的都是centos，运维在把你的软件从开发环境转移到生产环境的时候就会遇到一些Ubuntu转centos的问题，比如：有个特殊版本的数据库，只有Ubuntu支持，centos不支持，在转移的过程当中运维就得想办法解决这样的问题。这时候要是有docker你就可以把开发环境直接封装转移给运维，运维直接部署你给他的docker就可以了。而且部署速度快。3.在服务器负载方面，如果你单独开一个虚拟机，那么虚拟机会占用空闲内存的，docker部署的话，这些内存就会利用起来。总之docker就是集装箱原理。<br>【知乎精选】如何准确又通俗易懂地解释大数据及其应用价值？</p>
<p>【Wikipedia词条解释】</p>
<p>Big data is a collection of data sets so large and complex that it becomes difficult to process using on-hand database management tools or traditional data processing applications. The challenges include capture, curation, storage, search, sharing, transfer, analysis, and visualization. The trend to larger data sets is due to the additional information derivable from analysis of a single large set of related data, as compared to separate smaller sets with the same total amount of data, allowing correlations to be found to “spot business trends, determine quality of research, prevent diseases, link legal citations, combat crime, and determine real-time roadway traffic conditions.”</p>
<p>大数据说到底就是一个大字。到底有多大？拿维基百科上的例子来说，CERN做的LHC（大型強子對撞機）周长27公里，里面一共有1.5亿个传感器，每秒钟读数达四千万次。每秒钟发生的粒子对撞高达6亿次。剔除99.999%的无用数据，每秒钟也有100次碰撞需要记录。如果在这些数据里面仅仅使用十万分之一，那么一年也要积累25 petabytes的数据，相当于25000个1TB的硬盘。</p>
<p>在这些数据里寻找希格斯玻色子的证据，是真正的大海捞针。这么大的数据你给我用Excel算算看？不要说计算，根本连载入内存都不可能。</p>
<p>再比如说，Facebook据说拥有500亿以上的用户照片。前些日子美国波士顿发生了爆炸案。这些照片里可能就有爆炸案的线索。那你给我找找看那张照片上面有嫌犯？波士顿马拉松仅运动员就有两三万人，围观群众近五十万。在同一时间同一地点拍摄的照片可能有几十万张，录像可能有几千小时。用人工一张一张看过来是不切实际的。如果要考察爆炸案前后几天的照片那就更不现实了。还有的照片根本就没有时间和地点信息。</p>
<p>再举一个例子。2009年华盛顿大学的研究人员使用15万张Flickr上的图片，重建了整个罗马城的3D模型。整个重建过程的计算使用了496个CPU核心，耗时8小时。如果每张照片按100KB计算，总数据量达到15GB。至少要达到这个级别的数据，才能称得上大数据。</p>
<p>大数据因为大，不仅远远超过人工的处理能力，也远远超过普通台式机的处理能力。只有特定的算法和特别设计的硬件架构才能够有效的处理大数据。简单说来，硬件上要把很多CPU或者很多台式机连起来，算法上采取分而治之的策略。有的数据前后没有关联，特别适合分而治之的方法。而处理互相联系多的数据就比较困难。如果只要寻找嫌犯的脸，可以对每张照片分别处理。如果要考虑连续拍摄的照片有些并没有捕捉到脸，但嫌犯的位置和穿着是相对不变的，这就要考虑照片之间的关系，要分而治之就相对困难一些。</p>
<p>举一个做加法的例子来说明分而治之。比如有两道加法题：34+18和54+39。这两道题目如果两个人分别计算，就比一个人计算要快一倍。这就是分治的优势。但是如果只有一道加法题怎么办？比如两个人要计算34+18，那只好一个人计算个位，一个人计算十位。十位上计算3+1=4，但是还必须考虑个位的进位。所以计算十位的人必须等待计算个位的人给出结果之后，再决定要不要在自己的结果上再加1。为了统一结果一等待，计算速度就变慢了，这就是我们说结果之间存在的关系拖慢计算。</p>
<p>既然大数据处理起来这么困难，为什么还要使用大数据？使用小数据不行吗？这就要说到大数据的应用。所谓机器学习，一般是首先建立一个数据之间关系的模型。然后通过数据来确定模型中的参数。这就是所谓训练。大多数模型都是比较简单的。建模的时候为了简便，往往忽略现实中的很多因素。但是数据多了以后，往往可以弥补模型的简陋。所以数据多是有好处的。</p>
<p>那么我们建立一个复杂的模型不行吗？可惜越复杂的模型参数就越多。训练所需要的数据量就越大。随着人类计算能力的增长，能处理的数据量越来越多，统计模型也不断变的更精细更复杂。计算能力，数据量，统计模型三者是相辅相成的。最近兴起的Deep Learning，就是在强大的计算能力辅助下，使用巨大的数据训练多层复杂模型的一种方法。</p>
<p>举一个糖果厂的例子。某糖果厂按比例生产红色和绿色两种糖果。作为一个传统的中国股民，我特别喜欢红色，讨厌绿色。但糖果是包起来的，外面看不出来。那怎么才知道这个糖果厂的生产比例是什么？最简单的模型就是，买一百粒糖果全部剥开看看。比如有60粒红色，我就得出结论说红色比例是0.6。买的糖果越多，估算出的比例和实际比例就越接近。</p>
<p>你说这模型也太弱智了吧。那么好，我们可以考虑食用色素的价格对糖果颜色的影响。通过观察红绿两色色素价格和糖果比例之间的关系，可以预测何时糖果厂会大量生产红色糖果。到时候我就买一堆放家里慢慢吃。但是注意，这计算就需要色素价格的数据了。我们还可以继续构建更加复杂的模型，比如考虑糖果的销量，竞争对手的产品颜色，厂长的心情，天气晴阴等等。考虑的因素越多，需要的数据也越多。</p>
<p>你说扯淡。天气和糖果有什么关系？老实说，有没有关系实在搞不清楚。如果把这个因素放到模型里，多多少少也能算出一点关系来。但算出有关系不代表真有关系。那能不能通过算法自动找出那些因素是真有关系，那些是假装有关系？这就是Deep Learning想要解决的一个问题。</p>
<p>话说回来，只要你考虑的因素正确，又有足够的数据来测算因素之间的关系，那往往可以提升模型的预测能力。所以统计模型在往精细和复杂的方向发展。有些预测能力看起来似乎不可思议。比如预测那些人和你会买同样的书和音乐，比如预测你下班回家的路会不会堵车。有些预测能力似乎稀松平常。比如你一句话还没说完，我大概就能猜到你下一句会说什么。这能力基本上每个人都有，但对计算机来说难如登天，简直如同神迹。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://Syq777.github.io/2019/04/28/数据库/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Syq">
      <meta itemprop="description" content="寻门而入，破门而出。">
      <meta itemprop="image" content="/images/image.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/28/数据库/" class="post-title-link" itemprop="url">数据库的思考</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-28 23:57:22" itemprop="dateCreated datePublished" datetime="2019-04-28T23:57:22+08:00">2019-04-28</time>
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>​    虽然本文标题很明确，但我的目的并不是讲如何使用数据库。因此，你应该已经掌握怎么写一个简单的 join query（联接查询）和CRUD操作（创建读取更新删除），否则你可能无法理解本文。这是唯一需要你了解的，其他的由我来讲解。</p>
<p>我会从一些计算机科学方面的知识谈起，比如时间复杂度。我知道有些人讨厌这个概念，但是没有它你就不能理解数据库内部的巧妙之处。由于这是个很大的话题，我将集中探讨我认为必要的内容：数据库处理SQL查询的方式。我仅仅介绍数据库背后的基本概念，以便在读完本文后你会对底层到底发生了什么有个很好的了解。</p>
<p>【译者注：关于时间复杂度。计算机科学中，算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。如果不了解这个概念建议先看看维基或百度百科，对于理解文章下面的内容很有帮助】</p>
<p>由于本文是个长篇技术文章，涉及到很多算法和数据结构知识，你尽可以慢慢读。有些概念比较难懂，你可以跳过，不影响理解整体内容。</p>
<p>这篇文章大约分为3个部分：</p>
<p>底层和上层数据库组件概况<br>查询优化过程概况<br>事务和缓冲池管理概况<br>回到基础<br>很久很久以前（在一个遥远而又遥远的星系……)，开发者必须确切地知道他们的代码需要多少次运算。他们把算法和数据结构牢记于心，因为他们的计算机运行缓慢，无法承受对CPU和内存的浪费。</p>
<p>在这一部分，我将提醒大家一些这类的概念，因为它们对理解数据库至关重要。我还会介绍数据库索引的概念。</p>
<p>O(1) vs O(n^2)<br>现今很多开发者不关心时间复杂度……他们是对的。</p>
<p>但是当你应对大量的数据（我说的可不只是成千上万哈）或者你要争取毫秒级操作，那么理解这个概念就很关键了。而且你猜怎么着，数据库要同时处理这两种情景！我不会占用你太长时间，只要你能明白这一点就够了。这个概念在下文会帮助我们理解什么是基于成本的优化。</p>
<p>概念<br>时间复杂度用来检验某个算法处理一定量的数据要花多长时间。为了描述这个复杂度，计算机科学家使用数学上的『简明解释算法中的大O符号』。这个表示法用一个函数来描述算法处理给定的数据需要多少次运算。</p>
<p>比如，当我说『这个算法是适用 O(某函数())』，我的意思是对于某些数据，这个算法需要 某函数(数据量) 次运算来完成。</p>
<p>重要的不是数据量，而是当数据量增加时运算如何增加。时间复杂度不会给出确切的运算次数，但是给出的是一种理念。</p>
<p>图中可以看到不同类型的复杂度的演变过程，我用了对数尺来建这个图。具体点儿说，数据量以很快的速度从1条增长到10亿条。我们可得到如下结论：</p>
<p>绿：O(1)或者叫常数阶复杂度，保持为常数（要不人家就不会叫常数阶复杂度了）。<br>红：O(log(n))对数阶复杂度，即使在十亿级数据量时也很低。<br>粉：最糟糕的复杂度是 O(n^2)，平方阶复杂度，运算数快速膨胀。<br>黑和蓝：另外两种复杂度（的运算数也是）快速增长。<br>例子<br>数据量低时，O(1) 和 O(n^2)的区别可以忽略不计。比如，你有个算法要处理2000条元素。</p>
<p>O(1) 算法会消耗 1 次运算<br>O(log(n)) 算法会消耗 7 次运算<br>O(n) 算法会消耗 2000 次运算<br>O(n*log(n)) 算法会消耗 14,000 次运算<br>O(n^2) 算法会消耗 4,000,000 次运算<br>O(1) 和 O(n^2) 的区别似乎很大（4百万）,但你最多损失 2 毫秒，只是一眨眼的功夫。确实，当今处理器每秒可处理上亿次的运算。这就是为什么性能和优化在很多IT项目中不是问题。</p>
<p>我说过，面临海量数据的时候，了解这个概念依然很重要。如果这一次算法需要处理 1,000,000 条元素（这对数据库来说也不算大）。</p>
<p>O(1) 算法会消耗 1 次运算<br>O(log(n)) 算法会消耗 14 次运算<br>O(n) 算法会消耗 1,000,000 次运算<br>O(n*log(n)) 算法会消耗 14,000,000 次运算<br>O(n^2) 算法会消耗 1,000,000,000,000 次运算<br>我没有具体算过，但我要说，用O(n^2) 算法的话你有时间喝杯咖啡（甚至再续一杯！）。如果在数据量后面加个0，那你就可以去睡大觉了。</p>
<p>继续深入<br>为了让你能明白</p>
<p>搜索一个好的哈希表会得到 O(1) 复杂度<br>搜索一个均衡的树会得到 O(log(n)) 复杂度<br>搜索一个阵列会得到 O(n) 复杂度<br>最好的排序算法具有 O(n*log(n)) 复杂度<br>糟糕的排序算法具有 O(n^2) 复杂度<br>注：在接下来的部分，我们将会研究这些算法和数据结构。</p>
<p>有多种类型的时间复杂度</p>
<p>一般情况场景<br>最佳情况场景<br>最差情况场景<br>时间复杂度经常处于最差情况场景。</p>
<p>这里我只探讨时间复杂度，但复杂度还包括：</p>
<p>算法的内存消耗<br>算法的磁盘 I/O 消耗<br>当然还有比 n^2 更糟糕的复杂度，比如：</p>
<p>n^4：差劲！我将要提到的一些算法具备这种复杂度。<br>3^n：更差劲！本文中间部分研究的一些算法中有一个具备这种复杂度（而且在很多数据库中还真的使用了）。<br>阶乘 n：你永远得不到结果，即便在少量数据的情况下。<br>n^n：如果你发展到这种复杂度了，那你应该问问自己IT是不是你的菜。<br>注：我并没有给出『大O表示法』的真正定义，只是利用这个概念。可以看看维基百科上的这篇文章。</p>
<p>合并排序<br>当你要对一个集合排序时你怎么做？什么？调用 sort() 函数……好吧，算你对了……但是对于数据库，你需要理解这个 sort() 函数的工作原理。</p>
<p>优秀的排序算法有好几个，我侧重于最重要的一种：合并排序。你现在可能还不了解数据排序有什么用，但看完查询优化部分后你就会知道了。再者，合并排序有助于我们以后理解数据库常见的联接操作，即合并联接 。</p>
<p>合并<br>与很多有用的算法类似，合并排序基于这样一个技巧：将 2 个大小为 N/2 的已排序序列合并为一个 N 元素已排序序列仅需要 N 次操作。这个方法叫做合并。</p>
<p>我们用个简单的例子来看看这是什么意思：</p>
<p>通过此图你可以看到，在 2 个 4元素序列里你只需要迭代一次，就能构建最终的8元素已排序序列，因为两个4元素序列已经排好序了：</p>
<p>1) 在两个序列中，比较当前元素（当前=头一次出现的第一个）<br>2) 然后取出最小的元素放进8元素序列中<br>3) 找到（两个）序列的下一个元素，(比较后)取出最小的<br>重复1、2、3步骤，直到其中一个序列中的最后一个元素<br>然后取出另一个序列剩余的元素放入8元素序列中。<br>这个方法之所以有效，是因为两个4元素序列都已经排好序，你不需要再『回到』序列中查找比较。</p>
<p>【译者注：合并排序详细原理，其中一个动图（原图较长，我做了删减）清晰的演示了上述合并排序的过程，而原文的叙述似乎没有这么清晰，不动戳大。】</p>
<p>既然我们明白了这个技巧，下面就是我的合并排序伪代码。</p>
<p>C</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>array mergeSort(array a)<br>   if(length(a)==1)<br>      return a[0];<br>   end if</p>
<p>   //recursive calls<br>   [left_array right_array] := split_into_2_equally_sized_arrays(a);<br>   array new_left_array := mergeSort(left_array);<br>   array new_right_array := mergeSort(right_array);</p>
<p>   //merging the 2 small ordered arrays into a big one<br>   array result := merge(new_left_array,new_right_array);<br>   return result;<br>合并排序是把问题拆分为小问题，通过解决小问题来解决最初的问题（注：这种算法叫分治法，即『分而治之、各个击破』）。如果你不懂，不用担心，我第一次接触时也不懂。如果能帮助你理解的话，我认为这个算法是个两步算法：</p>
<p>拆分阶段，将序列分为更小的序列<br>排序阶段，把小的序列合在一起（使用合并算法）来构成更大的序列<br>拆分阶段</p>
<p>在拆分阶段过程中，使用3个步骤将序列分为一元序列。步骤数量的值是 log(N) （因为 N=8, log(N)=3）。【译者注：底数为2，下文有说明】</p>
<p>我怎么知道这个的？</p>
<p>我是天才！一句话：数学。道理是每一步都把原序列的长度除以2，步骤数就是你能把原序列长度除以2的次数。这正好是对数的定义（在底数为2时）。</p>
<p>排序阶段</p>
<p>在排序阶段，你从一元序列开始。在每一个步骤中，你应用多次合并操作，成本一共是 N=8 次运算。</p>
<p>第一步，4 次合并，每次成本是 2 次运算。<br>第二步，2 次合并，每次成本是 4 次运算。<br>第三步，1 次合并，成本是 8 次运算。<br>因为有 log(N) 个步骤，整体成本是 N*log(N) 次运算。</p>
<p>【译者注：这个完整的动图演示了拆分和排序的全过程，不动戳大。】</p>
<p>合并排序的强大之处<br>为什么这个算法如此强大？</p>
<p>因为：</p>
<p>你可以更改算法，以便于节省内存空间，方法是不创建新的序列而是直接修改输入序列。<br>注：这种算法叫『原地算法』(in-place algorithm)</p>
<p>你可以更改算法，以便于同时使用磁盘空间和少量内存而避免巨量磁盘 I/O。方法是只向内存中加载当前处理的部分。在仅仅100MB的内存缓冲区内排序一个几个GB的表时，这是个很重要的技巧。<br>注：这种算法叫『外部排序』(external sorting)。</p>
<p>你可以更改算法，以便于在 多处理器/多线程/多服务器 上运行。<br>比如，分布式合并排序是Hadoop（那个著名的大数据框架）的关键组件之一。</p>
<p>这个算法可以点石成金（事实如此！）<br>这个排序算法在大多数（如果不是全部的话）数据库中使用，但是它并不是唯一算法。如果你想多了解一些，你可以看看 这篇论文，探讨的是数据库中常用排序算法的优势和劣势。</p>
<p>阵列，树和哈希表<br>既然我们已经了解了时间复杂度和排序背后的理念，我必须要向你介绍3种数据结构了。这个很重要，因为它们是现代数据库的支柱。我还会介绍数据库索引的概念。</p>
<p>阵列<br>二维阵列是最简单的数据结构。一个表可以看作是个阵列，比如：</p>
<p>B+树索引<br>查找一个特定值这个树挺好用，但是当你需要查找两个值之间的多个元素时，就会有大麻烦了。你的成本将是 O(N)，因为你必须查找树的每一个节点，以判断它是否处于那 2 个值之间（例如，对树使用中序遍历）。而且这个操作不是磁盘I/O有利的，因为你必须读取整个树。我们需要找到高效的范围查询方法。为了解决这个问题，现代数据库使用了一种修订版的树，叫做B+树。在一个B+树里：</p>
<p>只有最底层的节点（叶子节点）才保存信息（相关表的行位置）<br>其它节点只是在搜索中用来指引到正确节点的。<br>【译者注：参考 B+树 ， 二叉树遍历    维基百科】</p>
<p>database_index</p>
<p>你可以看到，节点更多了（多了两倍）。确实，你有了额外的节点，它们就是帮助你找到正确节点的『决策节点』（正确节点保存着相关表中行的位置）。但是搜索复杂度还是在 O(log(N))（只多了一层）。一个重要的不同点是，最底层的节点是跟后续节点相连接的。</p>
<p>用这个 B+树，假设你要找40到100间的值：</p>
<p>你只需要找 40（若40不存在则找40之后最贴近的值），就像你在上一个树中所做的那样。<br>然后用那些连接来收集40的后续节点，直到找到100。<br>比方说你找到了 M 个后续节点，树总共有 N 个节点。对指定节点的搜索成本是 log(N)，跟上一个树相同。但是当你找到这个节点，你得通过后续节点的连接得到 M 个后续节点，这需要 M 次运算。那么这次搜索只消耗了 M+log(N) 次运算，区别于上一个树所用的 N 次运算。此外，你不需要读取整个树（仅需要读 M+log(N) 个节点）,这意味着更少的磁盘访问。如果 M 很小（比如 200 行）并且 N 很大（1,000,000），那结果就是天壤之别了。</p>
<p>然而还有新的问题（又来了！）。如果你在数据库中增加或删除一行（从而在相关的 B+树索引里）：</p>
<p>你必须在B+树中的节点之间保持顺序，否则节点会变得一团糟，你无法从中找到想要的节点。<br>你必须尽可能降低B+树的层数，否则 O(log(N)) 复杂度会变成 O(N)。<br>换句话说，B+树需要自我整理和自我平衡。谢天谢地，我们有智能删除和插入。但是这样也带来了成本：在B+树中，插入和删除操作是 O(log(N)) 复杂度。所以有些人听到过使用太多索引不是个好主意这类说法。没错，你减慢了快速插入/更新/删除表中的一个行的操作，因为数据库需要以代价高昂的每索引 O(log(N)) 运算来更新表的索引。再者，增加索引意味着给事务管理器带来更多的工作负荷（在本文结尾我们会探讨这个管理器）。</p>
<p>想了解更多细节，你可以看看 Wikipedia 上这篇关于B+树的文章。如果你想要数据库中实现B+树的例子，看看MySQL核心开发人员写的这篇文章 和 这篇文章。两篇文章都致力于探讨 innoDB(MySQL引擎)如何处理索引。</p>
<p>哈希表<br>我们最后一个重要的数据结构是哈希表。当你想快速查找值时，哈希表是非常有用的。而且，理解哈希表会帮助我们接下来理解一个数据库常见的联接操作，叫做『哈希联接』。这个数据结构也被数据库用来保存一些内部的东西（比如锁表或者缓冲池，我们在下文会研究这两个概念）。</p>
<p>哈希表这种数据结构可以用关键字来快速找到一个元素。为了构建一个哈希表，你需要定义：</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://Syq777.github.io/2019/04/28/xshell和secureCRT/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Syq">
      <meta itemprop="description" content="寻门而入，破门而出。">
      <meta itemprop="image" content="/images/image.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/28/xshell和secureCRT/" class="post-title-link" itemprop="url">xshell和secureCRT的用法</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-28 23:56:12" itemprop="dateCreated datePublished" datetime="2019-04-28T23:56:12+08:00">2019-04-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-29 00:25:35" itemprop="dateModified" datetime="2019-04-29T00:25:35+08:00">2019-04-29</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/xshell和secureCRT/" itemprop="url" rel="index"><span itemprop="name">xshell和secureCRT</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h6 id="xshell和secureCRT"><a href="#xshell和secureCRT" class="headerlink" title="xshell和secureCRT"></a>xshell和secureCRT</h6><p>  作为一名测试人员，xshell和secureCRT用它们来查看日志、排查定位问题，用的时间长了总感觉只是摸着点皮毛，连这两个工具的名字以及它的工作原理都不清楚，就查了点资料来多了解下，虽然可能在日常工作中能用的也只是它的部分功能，但是多了解点还是好的，总得摸清底细嘛。</p>
<pre><code> Xshell是一个强大的安全终端模拟软件，它支持SSH1, SSH2, 以及Microsoft Windows 平台的TELNET 协议。Xshell 通过互联网到远程主机的安全连接以及它创新性的设计和特色帮助用户在复杂的网络环境中享受他们的工作。Xshell可以在Windows界面下用来访问远端不同系统下的服务器，从而比较好的达到远程控制终端的目的。

SecureCRT是一款支持[SSH](http://baike.baidu.com/view/16184.htm)（SSH1和SSH2）的[终端仿真](http://baike.baidu.com/view/190233.htm)程序，简单地说是Windows下登录UNIX或Linux服务器主机的软件。SecureCRT支持SSH，同时支持[Telnet](http://baike.baidu.com/view/44255.htm)和rlogin协议。SecureCRT是一款用于连接运行包括[Windows](http://baike.baidu.com/view/4821.htm)、[UNIX](http://baike.baidu.com/view/8095.htm)和VMS的理想工具。通过使用内含的VCP命令行程序可以进行[加密](http://baike.baidu.com/view/40927.htm)文件的传输。有流行CRTTelnet客户机的所有特点,包括:自动注册、对不同主机保持不同的特性、打印功能、颜色设置、可变屏幕尺寸、用户定义的键位图和优良的VT100,VT102,VT220和ANSI竞争.能从命令行中运行或从浏览器中运行.其它特点包括文本手稿、易于使用的工具条、用户的键位图编辑器、可定制的[ANSI](http://baike.baidu.com/view/185282.htm)颜色等.SecureCRT的SSH[协议支持](http://baike.baidu.com/view/63557.htm)DES,3DES和RC4密码和密码与[RSA](http://baike.baidu.com/view/7520.htm)鉴别。

我在工作中用的比较多的是Xshell,我感觉它的界面设计的比较简洁，用起来比较舒服，支持标签打开多个链接的时候比较方便，还可以设置快捷按钮保存常用命令。我接触的开发和测试来说，一般用Xshell就是查log了，并不会直接通过它做些文件传输工作，在这里就记录下Xshell的常用命令和它的一些小技巧。
</code></pre><p>   (1)命令ls——列出文件 </p>
<p>   ls -la 给出当前目录下所有文件的一个长列表，包括以句点开头的“隐藏”文件 </p>
<p>   ls a* 列出当前目录下以字母a开头的所有文件 </p>
<p>   ls -l *.doc 给出当前目录下以.doc结尾的所有文件 </p>
<p>   (2)命令cp——复制文件 </p>
<p>   cp afile afile.bak 把文件复制为新文件afile.bak </p>
<p>   cp afile /home/bible/ 把文件afile从当前目录复制到/home/bible/目录下 </p>
<p>   cp * /tmp 把当前目录下的所有未隐藏文件复制到/tmp/目录下 </p>
<p>   cp -a docs docs.bak 递归性地把当前目录下的docs目录复制为新目录docs.bak,保持文件属性，并复制所有的文件，包括以句点开头的隐藏文件。为了方便起见，-a选项包含-R选项 </p>
<p>   cp -i 在覆盖前询问用户 </p>
<p>   cp -v 告诉用户正在做什么 </p>
<p>   (3)命令mv——移动和重命名文件 </p>
<p>  mv aflie bfile 将afile重命名为bfile </p>
<p>  mv afile /tmp 把当前目录下的afile移动到/tmp/目录下 </p>
<p>  (4)命令rm——删除文件和目录 </p>
<p>  rm afile 删除文件afile </p>
<p>  rm * 删除当前目录下的所有文件（未隐藏文件）。rm命令不删除目录，除非也指定了-r(递归)参数。 </p>
<p>  rm -rf domed 删除domed目录以及它所包含的所有内容 </p>
<p>  rm -i a* 删除当前目录下所有以字母a开头的文件，并且在每次删除时，提示用户进行确认 </p>
<p> (5)命令cd——更改目录 </p>
<p> cd ~ 切换到主目录 </p>
<p> cd /tmp 切换到目录/tmp </p>
<p> cd dir 切换到当前目录下的dir目录 </p>
<p> cd / 切换到根目录 </p>
<p> cd .. 切换到到上一级目录 </p>
<p> cd ../.. 切换到上二级目录 </p>
<p> cd ~ 切换到用户目录，比如是root用户，则切换到/root下 </p>
<p> (6)命令mkdir——建立目录  </p>
<p> mkdir phots 在当前目录中建立名为photos的目录 </p>
<p> mkdir -p this/that/theother 在当前目录下建立指定的嵌套子目录 </p>
<p> (7)命令more、less——查看文件内容 </p>
<p> more /etc/passwd 查看/etc/passwd的内容 </p>
<p> 功能：分页显示命令</p>
<p> more file </p>
<p> more命令也可以通过管道符(|)与其他的命令一起使用,</p>
<p> 例如：   </p>
<p> ps ux|more  </p>
<p> ls|more </p>
<p> less /etc/passwd 查看/etc/passwd的内容 </p>
<p>(8)命令grep——搜索文件内容 </p>
<p>grep bible /etc/exports 在文件exports中查找包含bible的所有行 </p>
<p>tail -100 /var/log/apache/access.log|grep 404 在WEB服务器日志文件access.log的后100行中查找包含“404”的行 </p>
<p>tail -100 /var/log/apache/access.log|grep -v googlebot 在WEB服务器日志文件access.log的后100行中，查找没有被google访问的行 </p>
<p>grep -v ^# /etc/apache2/httpd.conf 在主apache配置文件中，查找所有非注释行 (10)命令find——查找文件 </p>
<p>find .-name *.rpm 在当前目录中查找rpm包 </p>
<p>find .|grep page 在当前目录及其子目录中查找文件名包含page的文件 locate traceroute 在系统的任何地方查找文件名包含traceroute的文件 </p>
<p>  这是在平时工作中比较常用的一些命令，自己还没有开始学习linux，以后如果开始学习并使用linux的话可能会接触更多的关于这方面的知识。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/image.jpg" alt="Syq">
            
              <p class="site-author-name" itemprop="name">Syq</p>
              <div class="site-description motion-element" itemprop="description">寻门而入，破门而出。</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives">
                
                    <span class="site-state-item-count">24</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">17</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">21</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/Syq777" title="GitHub &rarr; https://github.com/Syq777" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:sunwukong0616@gmail.com" title="E-Mail &rarr; mailto:sunwukong0616@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Syq</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.1.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.0"></script>

  <script src="/js/motion.js?v=7.1.0"></script>



  
  


  <script src="/js/affix.js?v=7.1.0"></script>

  <script src="/js/schemes/pisces.js?v=7.1.0"></script>




  

  


  <script src="/js/next-boot.js?v=7.1.0"></script>


  

  

  

  



  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
