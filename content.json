{"pages":[{"title":"","text":"ahsdjkhaksjd","link":"/about/新建文本文档.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"Hexo＋Next+github搭建个人Blog","text":"04.26Hexo＋Next+github搭建个人Blog参考文档 Hexo使用指南https://www.jianshu.com/p/84a8384be1ae hexo+next主题及我走过的坑https://www.jianshu.com/p/21c94eb7bcd1 ######hexo Next 主题下载和配置https://chentging.github.io/2018/05/14/hexo%EF%BC%9A%EF%BC%88%E4%B8%89%EF%BC%89hexo-Next-%E4%B8%BB%E9%A2%98%E4%B8%8B%E8%BD%BD%E5%92%8C%E9%85%8D%E7%BD%AE/","link":"/2019/04/26/Hexo＋Next+github搭建个人Blog/"},{"title":"Python自定义词云图","text":"04.13Python自定义词云图准备工作1、安装python环境 2、安装pycharm或者Anaconda Navigator 3、控制台安装wordcloud的库 ​ pip install jieba ​ pip install wordcloud ​ pip matplotlib 注意事项 注意文件的路径 自定义图片的选择很重要 py文件名字不要写成wordcloud Code 1234567891011121314151617181920212223242526272829303132333435363738import matplotlib.pyplot as pltimport jiebafrom PIL import Imagefrom wordcloud import WordCloud , ImageColorGeneratorfrom scipy.misc import imreadimport numpy as np#打开文件text = open(r&apos;.\\test123.txt&apos;,&apos;r&apos;).read()# print(text)#分词cut_text = jieba.cut(text)#结果返回给resultresult = &apos; &apos;.join(cut_text)#引入图片image = Image.open(&apos;.\\drug.jpg&apos;)graph = np.array(image)# print(result)wc = WordCloud( font_path=r&apos;.\\XHei.ttf&apos;, background_color=&apos;white&apos;, # width=500, # height=300, max_font_size=1000, # min_font_size=10, mask=graph)wc.generate(result)image_color = ImageColorGenerator(graph)wc.recolor(color_func=image_color)wc.to_file(r&apos;.\\cloud234.png&apos;)# plt.figure(&apos;test1&apos;)plt.imshow(wc)plt.imshow(wc.recolor(color_func=image_color))plt.axis(&quot;off&quot;)plt.show() 增强版1234567891011121314151617181920212223242526272829303132333435import matplotlib.pyplot as pltimport jiebafrom PIL import Imagefrom wordcloud import WordCloud , ImageColorGeneratorfrom scipy.misc import imreadimport numpy as nptext = open(r&apos;.\\test123.txt&apos;,&apos;r&apos;).read()# print(text)PNGcut_text = jieba.cut(text)result = &apos; &apos;.join(cut_text)image = Image.open(&apos;.\\img.png&apos;)graph = np.array(image)# print(result)wc = WordCloud( font_path=r&apos;.\\XHei.ttf&apos;, background_color=&apos;white&apos;, # width=500, # height=300, max_font_size=1000, collocations=False, # min_font_size=10, mask=graph)wc.generate(result)image_color = ImageColorGenerator(graph)wc.recolor(color_func=image_color)wc.to_file(r&apos;.\\xxx.png&apos;)# plt.figure(&apos;test1&apos;)plt.imshow(wc)plt.imshow(wc.recolor(color_func=image_color))plt.axis(&quot;off&quot;)plt.show()","link":"/2019/04/25/Python词云图/"},{"title":"ThinkPHP5环境搭建","text":"1、phpstudy tp5框架的配置ide： phpstrom首先把下载的tp5框架解压到www文件夹下面（rename）phpstudy的配置端口常规设置更改host，目录使得localhost可以直接访问出现的问题记录在youdao里面tp5的开发模式 2、 问localhost/index/index/index出现No input file specified.问题在哪里？访问localhost/index/index/index出现No input file specified.问题在哪里？ 访问localhost/index/index/index出现No input file specified.问题在哪里？ 2018-08-03 源自：快速入门ThinkPHP 5.0–基础篇 2-4250 浏览2 回答 首先，看一下你的app/index/controller/Index.php是否存在，里面有没有写好index方法。 然后，看一下你的网站根目录配置好了没有。我的配置的是到public中的。 然后就是你的httpd-conf文件里面的配置中的LoadModule rewrite_module modules/mod_rewrite.so模块有没有开启，还有AllowOverride的后面是不是All。 还有一个地方就是public/.htaccess中的一行改成这样的，index.php/$1中间加个’?’ RewriteRule ^(.*)$ index.php?/$1 [QSA,PT,L] 钟广文 那个问号的问题 3、php环境配置1、 安装目录不要有 中文 空格 2、 还有最好不要放在c盘（避免重装系统时需要重新配置） 问题： mysql端口冲突3306 3307？ phpstudy 找到文件更改 phomyadmin用户名密码 增加代码 具体忘了 mysql 端口问题：（本地有两个mysql 自己安装的 还有安装phpstudy自带的mysql）navcat打不开提示缺文件 （百度网盘我的资源目录下有缺少资源）端口冲突：修改端口解决办法:在mysql 安装目录下修改my.ini()找到 program data 文件夹（该文件夹默认为隐藏文件夹） (win10找不到文件) 服务里开启mysql服务 include require 区别 运行时的效果 对于错误的处理不同 require对于文件不存在停止执行 include 继续执行 require检查比较严格 用include遇到错误继续执行下面的代码。 自己开发时用require，方便检查错误。 上线用include 不能把错误暴露给 用户","link":"/2019/04/28/ThinkPHP5环境搭建/"},{"title":"微信小程序+java后台实现openid获取","text":"微信小程序+java后台实现openid获取https://blog.csdn.net/abgglive/article/details/80666807?tdsourcetag=s_pctim_aiomsg 注意事项 微信web开发工具的appid需要和java后台传的openid相同 有的jar包不存在用maven 关于获取小程序信息 appid 小程序授权 type为自动获取：authorization_code Codejava后台1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package com.mnpg.controller;import com.mnpg.utils.AesCbcUtil;import com.mnpg.utils.HttpRequest;import net.sf.json.JSONObject;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.ResponseBody;import java.util.HashMap;import java.util.Map;@Controller@RequestMapping(value = &quot;login&quot;)public class loginController {@ResponseBody@RequestMapping(value = &quot;login&quot;,method = RequestMethod.GET)public Map decodeUserInfo(String encryptedData, String iv, String code ) { System.out.println(&quot;*****************************************************&quot;); System.out.println(&quot;**************************&quot;); System.out.println(&quot;***************&quot;); System.out.println(encryptedData); System.out.println(iv); System.out.println(code); Map map = new HashMap(); //登录凭证不能为空 if (code == null || code.length() == 0) { map.put(&quot;status&quot;, 0); map.put(&quot;msg&quot;, &quot;code 不能为空&quot;); return map; } //小程序唯一标识 (在微信小程序管理后台获取) String wxspAppid = &quot;wxc12def8cd6487222&quot;; //小程序的 app secret (在微信小程序管理后台获取) String wxspSecret = &quot;2b2bd912cc3664ce4e174bed35dce11b&quot;; //授权（必填） String grant_type = &quot;authorization_code&quot;; //////////////// 1、向微信服务器 使用登录凭证 code 获取 session_key 和 openid //////////////// //请求参数 String params = &quot;appid=&quot; + wxspAppid + &quot;&amp;secret=&quot; + wxspSecret + &quot;&amp;js_code=&quot; + code + &quot;&amp;grant_type=&quot; + grant_type; System.out.println(params); //发送请求 String sr = HttpRequest.sendGet(&quot;https://api.weixin.qq.com/sns/jscode2session&quot;, params); //解析相应内容（转换成json对象） System.out.println(&quot;*****************************************************&quot;); System.out.println(sr); JSONObject json = JSONObject.fromObject(sr); //获取会话密钥（session_key） String session_key = json.get(&quot;session_key&quot;).toString(); //用户的唯一标识（openid） String openid = (String) json.get(&quot;openid&quot;); //////////////// 2、对encryptedData加密数据进行AES解密 //////////////// try { String result = AesCbcUtil.decrypt(encryptedData, session_key, iv, &quot;UTF-8&quot;); if (null != result &amp;&amp; result.length() &gt; 0) { map.put(&quot;status&quot;, 1); map.put(&quot;msg&quot;, &quot;解密成功&quot;); JSONObject userInfoJSON = JSONObject.fromObject(result); Map userInfo = new HashMap(); userInfo.put(&quot;openId&quot;, userInfoJSON.get(&quot;openId&quot;)); userInfo.put(&quot;nickName&quot;, userInfoJSON.get(&quot;nickName&quot;)); userInfo.put(&quot;gender&quot;, userInfoJSON.get(&quot;gender&quot;)); userInfo.put(&quot;city&quot;, userInfoJSON.get(&quot;city&quot;)); userInfo.put(&quot;province&quot;, userInfoJSON.get(&quot;province&quot;)); userInfo.put(&quot;country&quot;, userInfoJSON.get(&quot;country&quot;)); userInfo.put(&quot;avatarUrl&quot;, userInfoJSON.get(&quot;avatarUrl&quot;)); userInfo.put(&quot;unionId&quot;, userInfoJSON.get(&quot;unionId&quot;)); map.put(&quot;userInfo&quot;, userInfo); return map; } } catch (Exception e) { e.printStackTrace(); } map.put(&quot;status&quot;, 0); map.put(&quot;msg&quot;, &quot;解密失败&quot;); return map;}} web开发app.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//app.jsApp({ onLaunch: function () { // 展示本地存储能力 // var logs = wx.getStorageSync(&apos;logs&apos;) || [] // logs.unshift(Date.now()) // wx.setStorageSync(&apos;logs&apos;, logs) // 登录 wx.login({ success: function (res) { var code = res.code;//登录凭证 if (code) { //2、调用获取用户信息接口 wx.getUserInfo({ success: function (res) { console.log({ encryptedData: res.encryptedData, iv: res.iv, code: code }) //3.请求自己的服务器，解密用户信息 获取unionId等加密信息 wx.request({ url: &apos;http://localhost:8080/login/login&apos;,//自己的服务接口地址 method: &apos;get&apos;, header: { &quot;Content-Type&quot;: &quot;applciation/json&quot; }, data: { encryptedData: res.encryptedData, iv: res.iv, code: code }, success: function (data) { //4.解密成功后 获取自己服务器返回的结果 if (data.data.status == 1) { var userInfo_ = data.data.userInfo; console.log(userInfo_) } else { console.log(&apos;解密失败&apos;) } }, fail: function () { console.log(&apos;系统错误&apos;) } }) }, fail: function () { console.log(&apos;获取用户信息失败&apos;) } }) } else { console.log(&apos;获取用户登录态失败！&apos; + r.errMsg) } }, fail: function () { console.log(&apos;登陆失败&apos;) } }), // 获取用户信息 wx.getSetting({ success: res =&gt; { if (res.authSetting[&apos;scope.userInfo&apos;]) { // 已经授权，可以直接调用 getUserInfo 获取头像昵称，不会弹框 wx.getUserInfo({ success: res =&gt; { // 可以将 res 发送给后台解码出 unionId this.globalData.userInfo = res.userInfo // 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回 // 所以此处加入 callback 以防止这种情况 if (this.userInfoReadyCallback) { this.userInfoReadyCallback(res) } } }) } } }) }, globalData: { userInfo: null }})","link":"/2019/04/22/微信小程序+java后台实现openid获取/"},{"title":"开始屏幕的磁贴重启后自动还原","text":"开始屏幕的磁贴重启后自动还原我们在测试时，开始磁贴能够正常保存且在该路径下并没有发现您说的文件。 请您尝试使用Dism命令修复下系统。 在小娜中搜索命令提示符，右击以管理员身份运行命令提示符，输入以下命令 扫描映像是否完整： DISM.exe /Online /Cleanup-image /Scanhealth 完成后再检测映像： DISM.exe /Online /Cleanup-image /Checkhealth 然后再修复映像： DISM.exe /Online /Cleanup-image /Restorehealth 最后检查系统并修复： sfc /scannow 如果问题依旧，请新建一个本地管理员账户，在新建的账户中查看问题是否存在。 在小娜中搜索命令提示符，右击以管理员运行命令提示符，粘贴输入下面两行指令新建一个管理员本地账户： net user User 789456 /add （User是新建账户名，789456是新建密码，名称和密码根据需要都可以修改） net localgroup administrators User /add （为该账户添加管理员权限） 希望以上信息能够帮助到您。","link":"/2019/04/29/开始屏幕的磁贴一重启就自动还原,求助! - Microsoft Community/"},{"title":"有道云笔记整理","text":"Mysql MySQL server has gone away 问题的解决方法 - Boblim - 博客园 解决mysql执行SQL文件，报错：”Got a packet bigger than ‘max_allowed_packet’ bytes“ - github_39325328的博客 - CSDN博客 https://blog.csdn.net/wqy18210176544/article/details/77235203 Mysql&amp;Centos 如何搭建lamp(CentOS7+Apache+MySQL+PHP)环境 - Lily_Lee - 博客园 CentOS 7 下使用yum安装MySQL5.7.20 最简单 图文详解 - 冰恋云的专栏 - CSDN博客 Maven 如何使用IntelliJ IDEA 配置Maven - westos_linux的博客 - CSDN博客 maven 本地仓库的配置以及如何修改默认.m2仓库位置 - 请叫我大师兄 - CSDN博客 https://blog.csdn.net/qq_36565494/article/details/81940336 ######","link":"/2019/04/28/有道云笔记整理/"},{"title":"本地java web项目放到服务器的步骤","text":"本地java web项目放到服务器的步骤注意 jar包的问题 （eclipce）1、在服务器配置jdk还有mysql数据库 ，以及安装tomcat2、.修改tomcat的conf/server.xml文件https://blog.csdn.net/crazy_java_beginner/article/details/72841124 （idea maven）1、在本地是正常的，因maven会优先使用本地版本的jar包2、idea如果在本地只有localhost 的话3、应该是清空webapp里面的root目录文件 把解压出来的war包文件放进去 idea打war包：首先clean 然后install","link":"/2019/04/28/本地java web项目放到服务器的步骤/"},{"title":"Google书签整理","text":"Spring SpringMVC中的/*和/的区别 - zuojunyuan - 博客园 Spring注入方式，Spring入门篇教程-慕课网 idea IntelliJ IDEA（2017）安装和破解 - CSDN博客 Idea 14 最详细创建最简单web项目，并且发布在tomcat - CSDN博客 IntelliJ IDEA 注册码 IDEA用maven创建springMVC项目和配置 - 幻梦_坤 - 博客园 web 一个完整Java Web项目背后的密码 - 终端研发部 - SegmentFault 思否 网页分页功能的实现 - OverZeal - 博客园 JSP 学习笔记 - CSDN博客 Struts2 Struts2学习（1）：Struts2框架结构详解 - CSDN博客 在eclipse中搭建struts2框架的详细过程 - CSDN博客 https://www.csls.cdb.com.cn/csls.online.reg.ActionStudentTemp.do?doType=findPassword “HTTP Status 404 - No result defined for action ** and result result”错误解决方法 - CSDN博客 action的几种映射方式 - gdwang - ITeye博客 网络 Cisco packet tracer 7.0登录问题解决 - CSDN博客 NATAPP基于ngrok的国内高速内网穿透服务 Tools eclipse环境下如何配置tomcat，并且把项目部署到Tomcat服务器上 - CSDN博客 DB mysql 时间戳的使用! - orac - 博客园 MySQL5.7完全卸载 - wingman的博客 - CSDN博客 Video SpringMVC+Mybatis由浅入深全套视频教程 - 爱酷学习网，免费高清视频教程在线观看 PHP实现微信公众平台开发—基础篇用户评价慕课网 什么是 CDN - 卢小喵的学习笔记 - CSDN博客 syq777的个人空间 - 哔哩哔哩 ( ゜- ゜)つロ 乾杯~ Bilibili error 关于maven 操作中断导致 maven clean失败的分析 - Carry的博客 - CSDN博客 访问localhost/index/index/index出现No input file…_慕课问答 Win10设置不能保存，添加应用磁贴重启后恢复原状问题 - ai520587的博客 - CSDN博客 IDEA中Maven依赖包下载不了的问题解决方案汇总 - 猫的瞳 - CSDN博客 php php教程_phpStudy官方网站_JspStudy phpStudy 2017下载_phpStudy教程_php集成环境 - phpStudy ThinkPHP初学者：写一个简单登录页面（一） - 简书 thinkPHP5——后端之登录注册修改用户信息 - angryshan的博客 - CSDN博客 ThinkPHP实现用户注册、登录模块 - 小小梦想家 - CSDN博客 Study 一分钟学会使用CDN - Lunaqi的博客 - CSDN博客 BigData 首页 数据酷客，中国领先的大数据教育云平台-‘数据科学与大数据技术’，’大数据技术与应用’ Docker Centos7上安装docker - 风止雨歇 - 博客园 Git Git的使用–如何将本地项目上传到GitHub - 喵喵喵~的博客 - CSDN博客 如何搭建lamp(CentOS7+Apache+MySQL+PHP)环境 - Lily_Lee - 博客园 Linux CentOS7 64位安装mysql教程，亲测完美 - 大爱猫plus的博客 - CSDN博客 Centos7Bind正反区域配置 - 游离态De猫 - CSDN博客 CentOS7.3使用BIND配置DNS服务器(一) - miouqi的专栏 - CSDN博客 linux — bind安装使用-千里之行始于足下-51CTO博客 aliyun centOS7下安装GUI图形界面 - 阿里云 云服务器管理控制台 阿里云三台节点，搭建完全分布式hadoop集群,超简单 - zhangshk_的博客 - CSDN博客 Hadoop “Name node is in safe mode” 错误解决方法_服务器应用_Linux公社-Linux系统门户网站 分布式集群环境hadoop、hbase、zookeeper搭建（全） | IT瘾 云服务器搭建hadoop集群 - Willian - CSDN博客 Hadoop Hadoop - Apache Hadoop 2.9.2 CentOS7安装Hadoop2.7.3完整流程及总结 - 阿里云 （超详细版）Linux下Hadoop2.7.1集群环境的搭建（3台为例） - 要杰的个人空间 - 开源中国 Linux下Hadoop2.7.1集群环境的搭建（超详细版） - xueqinna的专栏 - CSDN博客 org.apache.hadoop.hdfs.server.namenode.SafeModeException - qq_36470908的博客 - CSDN博客 Ipython 入门｜始于Jupyter Notebooks：一份全面的初学者实用指南 通俗易懂的泰坦尼克号生存分析（titanic） - 离散梦 - CSDN博客 泰坦尼克号乘客生存分析——用机器学习告诉你，如果你在当时的船上，有多大机率生还？ - 简书 pandas介绍——实例分析：泰坦尼克号数据分析（10） - 王伟健的博客 - CSDN博客 机器学习系列(3)_逻辑回归应用之Kaggle泰坦尼克之灾 - 寒小阳 - CSDN博客 Kaggle入门：逻辑回归应用之Kaggle泰坦尼克之灾 - Kesci.com 数据挖掘项目（一）Airbnb 新用户的民宿预定结果预测 - Datawhale的博客 - CSDN博客 Other文档服务 下载页 微信小程序保持会话session - 程序员阿坤的博客 - CSDN博客 微信用户访问小程序的登录过程 - Sam哥哥聊技术 - CSDN博客","link":"/2019/04/27/Google书签整理/"},{"title":"数据库的思考","text":"​ 虽然本文标题很明确，但我的目的并不是讲如何使用数据库。因此，你应该已经掌握怎么写一个简单的 join query（联接查询）和CRUD操作（创建读取更新删除），否则你可能无法理解本文。这是唯一需要你了解的，其他的由我来讲解。 我会从一些计算机科学方面的知识谈起，比如时间复杂度。我知道有些人讨厌这个概念，但是没有它你就不能理解数据库内部的巧妙之处。由于这是个很大的话题，我将集中探讨我认为必要的内容：数据库处理SQL查询的方式。我仅仅介绍数据库背后的基本概念，以便在读完本文后你会对底层到底发生了什么有个很好的了解。 【译者注：关于时间复杂度。计算机科学中，算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。如果不了解这个概念建议先看看维基或百度百科，对于理解文章下面的内容很有帮助】 由于本文是个长篇技术文章，涉及到很多算法和数据结构知识，你尽可以慢慢读。有些概念比较难懂，你可以跳过，不影响理解整体内容。 这篇文章大约分为3个部分： 底层和上层数据库组件概况查询优化过程概况事务和缓冲池管理概况回到基础很久很久以前（在一个遥远而又遥远的星系……)，开发者必须确切地知道他们的代码需要多少次运算。他们把算法和数据结构牢记于心，因为他们的计算机运行缓慢，无法承受对CPU和内存的浪费。 在这一部分，我将提醒大家一些这类的概念，因为它们对理解数据库至关重要。我还会介绍数据库索引的概念。 O(1) vs O(n^2)现今很多开发者不关心时间复杂度……他们是对的。 但是当你应对大量的数据（我说的可不只是成千上万哈）或者你要争取毫秒级操作，那么理解这个概念就很关键了。而且你猜怎么着，数据库要同时处理这两种情景！我不会占用你太长时间，只要你能明白这一点就够了。这个概念在下文会帮助我们理解什么是基于成本的优化。 概念时间复杂度用来检验某个算法处理一定量的数据要花多长时间。为了描述这个复杂度，计算机科学家使用数学上的『简明解释算法中的大O符号』。这个表示法用一个函数来描述算法处理给定的数据需要多少次运算。 比如，当我说『这个算法是适用 O(某函数())』，我的意思是对于某些数据，这个算法需要 某函数(数据量) 次运算来完成。 重要的不是数据量，而是当数据量增加时运算如何增加。时间复杂度不会给出确切的运算次数，但是给出的是一种理念。 图中可以看到不同类型的复杂度的演变过程，我用了对数尺来建这个图。具体点儿说，数据量以很快的速度从1条增长到10亿条。我们可得到如下结论： 绿：O(1)或者叫常数阶复杂度，保持为常数（要不人家就不会叫常数阶复杂度了）。红：O(log(n))对数阶复杂度，即使在十亿级数据量时也很低。粉：最糟糕的复杂度是 O(n^2)，平方阶复杂度，运算数快速膨胀。黑和蓝：另外两种复杂度（的运算数也是）快速增长。例子数据量低时，O(1) 和 O(n^2)的区别可以忽略不计。比如，你有个算法要处理2000条元素。 O(1) 算法会消耗 1 次运算O(log(n)) 算法会消耗 7 次运算O(n) 算法会消耗 2000 次运算O(n*log(n)) 算法会消耗 14,000 次运算O(n^2) 算法会消耗 4,000,000 次运算O(1) 和 O(n^2) 的区别似乎很大（4百万）,但你最多损失 2 毫秒，只是一眨眼的功夫。确实，当今处理器每秒可处理上亿次的运算。这就是为什么性能和优化在很多IT项目中不是问题。 我说过，面临海量数据的时候，了解这个概念依然很重要。如果这一次算法需要处理 1,000,000 条元素（这对数据库来说也不算大）。 O(1) 算法会消耗 1 次运算O(log(n)) 算法会消耗 14 次运算O(n) 算法会消耗 1,000,000 次运算O(n*log(n)) 算法会消耗 14,000,000 次运算O(n^2) 算法会消耗 1,000,000,000,000 次运算我没有具体算过，但我要说，用O(n^2) 算法的话你有时间喝杯咖啡（甚至再续一杯！）。如果在数据量后面加个0，那你就可以去睡大觉了。 继续深入为了让你能明白 搜索一个好的哈希表会得到 O(1) 复杂度搜索一个均衡的树会得到 O(log(n)) 复杂度搜索一个阵列会得到 O(n) 复杂度最好的排序算法具有 O(n*log(n)) 复杂度糟糕的排序算法具有 O(n^2) 复杂度注：在接下来的部分，我们将会研究这些算法和数据结构。 有多种类型的时间复杂度 一般情况场景最佳情况场景最差情况场景时间复杂度经常处于最差情况场景。 这里我只探讨时间复杂度，但复杂度还包括： 算法的内存消耗算法的磁盘 I/O 消耗当然还有比 n^2 更糟糕的复杂度，比如： n^4：差劲！我将要提到的一些算法具备这种复杂度。3^n：更差劲！本文中间部分研究的一些算法中有一个具备这种复杂度（而且在很多数据库中还真的使用了）。阶乘 n：你永远得不到结果，即便在少量数据的情况下。n^n：如果你发展到这种复杂度了，那你应该问问自己IT是不是你的菜。注：我并没有给出『大O表示法』的真正定义，只是利用这个概念。可以看看维基百科上的这篇文章。 合并排序当你要对一个集合排序时你怎么做？什么？调用 sort() 函数……好吧，算你对了……但是对于数据库，你需要理解这个 sort() 函数的工作原理。 优秀的排序算法有好几个，我侧重于最重要的一种：合并排序。你现在可能还不了解数据排序有什么用，但看完查询优化部分后你就会知道了。再者，合并排序有助于我们以后理解数据库常见的联接操作，即合并联接 。 合并与很多有用的算法类似，合并排序基于这样一个技巧：将 2 个大小为 N/2 的已排序序列合并为一个 N 元素已排序序列仅需要 N 次操作。这个方法叫做合并。 我们用个简单的例子来看看这是什么意思： 通过此图你可以看到，在 2 个 4元素序列里你只需要迭代一次，就能构建最终的8元素已排序序列，因为两个4元素序列已经排好序了： 1) 在两个序列中，比较当前元素（当前=头一次出现的第一个）2) 然后取出最小的元素放进8元素序列中3) 找到（两个）序列的下一个元素，(比较后)取出最小的重复1、2、3步骤，直到其中一个序列中的最后一个元素然后取出另一个序列剩余的元素放入8元素序列中。这个方法之所以有效，是因为两个4元素序列都已经排好序，你不需要再『回到』序列中查找比较。 【译者注：合并排序详细原理，其中一个动图（原图较长，我做了删减）清晰的演示了上述合并排序的过程，而原文的叙述似乎没有这么清晰，不动戳大。】 既然我们明白了这个技巧，下面就是我的合并排序伪代码。 C 12345678910111213array mergeSort(array a) if(length(a)==1) return a[0]; end if //recursive calls [left_array right_array] := split_into_2_equally_sized_arrays(a); array new_left_array := mergeSort(left_array); array new_right_array := mergeSort(right_array); //merging the 2 small ordered arrays into a big one array result := merge(new_left_array,new_right_array); return result;合并排序是把问题拆分为小问题，通过解决小问题来解决最初的问题（注：这种算法叫分治法，即『分而治之、各个击破』）。如果你不懂，不用担心，我第一次接触时也不懂。如果能帮助你理解的话，我认为这个算法是个两步算法： 拆分阶段，将序列分为更小的序列排序阶段，把小的序列合在一起（使用合并算法）来构成更大的序列拆分阶段 在拆分阶段过程中，使用3个步骤将序列分为一元序列。步骤数量的值是 log(N) （因为 N=8, log(N)=3）。【译者注：底数为2，下文有说明】 我怎么知道这个的？ 我是天才！一句话：数学。道理是每一步都把原序列的长度除以2，步骤数就是你能把原序列长度除以2的次数。这正好是对数的定义（在底数为2时）。 排序阶段 在排序阶段，你从一元序列开始。在每一个步骤中，你应用多次合并操作，成本一共是 N=8 次运算。 第一步，4 次合并，每次成本是 2 次运算。第二步，2 次合并，每次成本是 4 次运算。第三步，1 次合并，成本是 8 次运算。因为有 log(N) 个步骤，整体成本是 N*log(N) 次运算。 【译者注：这个完整的动图演示了拆分和排序的全过程，不动戳大。】 合并排序的强大之处为什么这个算法如此强大？ 因为： 你可以更改算法，以便于节省内存空间，方法是不创建新的序列而是直接修改输入序列。注：这种算法叫『原地算法』(in-place algorithm) 你可以更改算法，以便于同时使用磁盘空间和少量内存而避免巨量磁盘 I/O。方法是只向内存中加载当前处理的部分。在仅仅100MB的内存缓冲区内排序一个几个GB的表时，这是个很重要的技巧。注：这种算法叫『外部排序』(external sorting)。 你可以更改算法，以便于在 多处理器/多线程/多服务器 上运行。比如，分布式合并排序是Hadoop（那个著名的大数据框架）的关键组件之一。 这个算法可以点石成金（事实如此！）这个排序算法在大多数（如果不是全部的话）数据库中使用，但是它并不是唯一算法。如果你想多了解一些，你可以看看 这篇论文，探讨的是数据库中常用排序算法的优势和劣势。 阵列，树和哈希表既然我们已经了解了时间复杂度和排序背后的理念，我必须要向你介绍3种数据结构了。这个很重要，因为它们是现代数据库的支柱。我还会介绍数据库索引的概念。 阵列二维阵列是最简单的数据结构。一个表可以看作是个阵列，比如： B+树索引查找一个特定值这个树挺好用，但是当你需要查找两个值之间的多个元素时，就会有大麻烦了。你的成本将是 O(N)，因为你必须查找树的每一个节点，以判断它是否处于那 2 个值之间（例如，对树使用中序遍历）。而且这个操作不是磁盘I/O有利的，因为你必须读取整个树。我们需要找到高效的范围查询方法。为了解决这个问题，现代数据库使用了一种修订版的树，叫做B+树。在一个B+树里： 只有最底层的节点（叶子节点）才保存信息（相关表的行位置）其它节点只是在搜索中用来指引到正确节点的。【译者注：参考 B+树 ， 二叉树遍历 维基百科】 database_index 你可以看到，节点更多了（多了两倍）。确实，你有了额外的节点，它们就是帮助你找到正确节点的『决策节点』（正确节点保存着相关表中行的位置）。但是搜索复杂度还是在 O(log(N))（只多了一层）。一个重要的不同点是，最底层的节点是跟后续节点相连接的。 用这个 B+树，假设你要找40到100间的值： 你只需要找 40（若40不存在则找40之后最贴近的值），就像你在上一个树中所做的那样。然后用那些连接来收集40的后续节点，直到找到100。比方说你找到了 M 个后续节点，树总共有 N 个节点。对指定节点的搜索成本是 log(N)，跟上一个树相同。但是当你找到这个节点，你得通过后续节点的连接得到 M 个后续节点，这需要 M 次运算。那么这次搜索只消耗了 M+log(N) 次运算，区别于上一个树所用的 N 次运算。此外，你不需要读取整个树（仅需要读 M+log(N) 个节点）,这意味着更少的磁盘访问。如果 M 很小（比如 200 行）并且 N 很大（1,000,000），那结果就是天壤之别了。 然而还有新的问题（又来了！）。如果你在数据库中增加或删除一行（从而在相关的 B+树索引里）： 你必须在B+树中的节点之间保持顺序，否则节点会变得一团糟，你无法从中找到想要的节点。你必须尽可能降低B+树的层数，否则 O(log(N)) 复杂度会变成 O(N)。换句话说，B+树需要自我整理和自我平衡。谢天谢地，我们有智能删除和插入。但是这样也带来了成本：在B+树中，插入和删除操作是 O(log(N)) 复杂度。所以有些人听到过使用太多索引不是个好主意这类说法。没错，你减慢了快速插入/更新/删除表中的一个行的操作，因为数据库需要以代价高昂的每索引 O(log(N)) 运算来更新表的索引。再者，增加索引意味着给事务管理器带来更多的工作负荷（在本文结尾我们会探讨这个管理器）。 想了解更多细节，你可以看看 Wikipedia 上这篇关于B+树的文章。如果你想要数据库中实现B+树的例子，看看MySQL核心开发人员写的这篇文章 和 这篇文章。两篇文章都致力于探讨 innoDB(MySQL引擎)如何处理索引。 哈希表我们最后一个重要的数据结构是哈希表。当你想快速查找值时，哈希表是非常有用的。而且，理解哈希表会帮助我们接下来理解一个数据库常见的联接操作，叫做『哈希联接』。这个数据结构也被数据库用来保存一些内部的东西（比如锁表或者缓冲池，我们在下文会研究这两个概念）。 哈希表这种数据结构可以用关键字来快速找到一个元素。为了构建一个哈希表，你需要定义：","link":"/2019/04/28/数据库/"},{"title":"Java面试题集及参考答案","text":"超级全面的Java面试题集及参考答案https://blog.csdn.net/dd864140130/article/details/55833087 今天要谈的主题是关于求职.求职是在每个技术人员的生涯中都要经历多次,对于我们大部分人而言,在进入自己心仪的公司之前少不了准备工作,有一份全面细致面试题将帮助我们减少许多麻烦.在跳槽季来临之前,特地做这个系列的文章,一方面帮助自己巩固下基础,另一方面也希望帮助想要换工作的朋友. 相关概念面向对象的三个特征封装,继承,多态.这个应该是人人皆知.有时候也会加上抽象.多态的好处允许不同类对象对同一消息做出响应,即同一消息可以根据发送对象的不同而采用多种不同的行为方式(发送消息就是函数调用).主要有以下优点: 可替换性:多态对已存在代码具有可替换性. 可扩充性:增加新的子类不影响已经存在的类结构. 接口性:多态是超类通过方法签名,向子类提供一个公共接口,由子类来完善或者重写它来实现的. 灵活性. 简化性.代码中如何实现多态实现多态主要有以下三种方式: 接口实现 继承父类重写方法 同一类中进行方法重载 虚拟机是如何实现多态的动态绑定技术(dynamic binding),执行期间判断所引用对象的实际类型,根据实际类型调用对应的方法.接口的意义接口的意义用三个词就可以概括:规范,扩展,回调.抽象类的意义抽象类的意义可以用三句话来概括: 为其他子类提供一个公共的类型 封装子类中重复定义的内容 定义抽象方法,子类虽然有不同的实现,但是定义时一致的接口和抽象类的区别 比较 抽象类 接口 默认方法 抽象类可以有默认的方法实现 java 8之前,接口中不存在方法的实现. 实现方式 子类使用extends关键字来继承抽象类.如果子类不是抽象类,子类需要提供抽象类中所声明方法的实现. 子类使用implements来实现接口,需要提供接口中所有声明的实现. 构造器 抽象类中可以有构造器, 接口中不能 和正常类区别 抽象类不能被实例化 接口则是完全不同的类型 访问修饰符 抽象方法可以有public,protected和default等修饰 接口默认是public,不能使用其他修饰符 多继承 一个子类只能存在一个父类 一个子类可以存在多个接口 添加新方法 想抽象类中添加新方法,可以提供默认的实现,因此可以不修改子类现有的代码 如果往接口中添加新方法,则子类中需要实现该方法. 父类的静态方法能否被子类重写不能.重写只适用于实例方法,不能用于静态方法,而子类当中含有和父类相同签名的静态方法,我们一般称之为隐藏.什么是不可变对象不可变对象指对象一旦被创建，状态就不能再改变。任何修改都会创建一个新的对象，如 String、Integer及其它包装类。静态变量和实例变量的区别?静态变量存储在方法区,属于类所有.实例变量存储在堆当中,其引用存在当前线程栈.能否创建一个包含可变对象的不可变对象?当然可以创建一个包含可变对象的不可变对象的，你只需要谨慎一点，不要共享可变对象的引用就可以了，如果需要变化时，就返回原对象的一个拷贝。最常见的例子就是对象中包含一个日期对象的引用.java 创建对象的几种方式 采用new 通过反射 采用clone 通过序列化机制前2者都需要显式地调用构造方法. 造成耦合性最高的恰好是第一种,因此你发现无论什么框架,只要涉及到解耦必先减少new的使用.switch中能否使用string做参数在idk 1.7之前,switch只能支持byte,short,char,int或者其对应的封装类以及Enum类型。从idk 1.7之后switch开始支持String.switch能否作用在byte,long上?可以用在byte上,但是不能用在long上.String s1=”ab”,String s2=”a”+”b”,String s3=”a”,String s4=”b”,s5=s3+s4请问s5==s2返回什么?返回false.在编译过程中,编译器会将s2直接优化为”ab”,会将其放置在常量池当中,s5则是被创建在堆区,相当于s5=new String(“ab”);你对String对象的intern()熟悉么?intern()方法会首先从常量池中查找是否存在该常量值,如果常量池中不存在则现在常量池中创建,如果已经存在则直接返回.比如String s1=”aa”;String s2=s1.intern();System.out.print(s1==s2);//返回trueObject中有哪些公共方法? equals() clone() getClass() notify(),notifyAll(),wait() toStringjava当中的四种引用强引用,软引用,弱引用,虚引用.不同的引用类型主要体现在GC上: 强引用：如果一个对象具有强引用，它就不会被垃圾回收器回收。即使当前内存空间不足，JVM也不会回收它，而是抛出 OutOfMemoryError 错误，使程序异常终止。如果想中断强引用和某个对象之间的关联，可以显式地将引用赋值为null，这样一来的话，JVM在合适的时间就会回收该对象 软引用：在使用软引用时，如果内存的空间足够，软引用就能继续被使用，而不会被垃圾回收器回收，只有在内存不足时，软引用才会被垃圾回收器回收。 弱引用：具有弱引用的对象拥有的生命周期更短暂。因为当 JVM 进行垃圾回收，一旦发现弱引用对象，无论当前内存空间是否充足，都会将弱引用回收。不过由于垃圾回收器是一个优先级较低的线程，所以并不一定能迅速发现弱引用对象 虚引用：顾名思义，就是形同虚设，如果一个对象仅持有虚引用，那么它相当于没有引用，在任何时候都可能被垃圾回收器回收。 更多了解参见深入对象引用：http://blog.csdn.net/dd864140130/article/details/49885811WeakReference与SoftReference的区别?这点在四种引用类型中已经做了解释,这里简单说明一下即可:虽然 WeakReference 与 SoftReference 都有利于提高 GC 和 内存的效率，但是 WeakReference ，一旦失去最后一个强引用，就会被 GC 回收，而软引用虽然不能阻止被回收，但是可以延迟到 JVM 内存不足的时候。为什么要有不同的引用类型不像C语言,我们可以控制内存的申请和释放,在Java中有时候我们需要适当的控制对象被回收的时机,因此就诞生了不同的引用类型,可以说不同的引用类型实则是对GC回收时机不可控的妥协.有以下几个使用场景可以充分的说明: 利用软引用和弱引用解决OOM问题：用一个HashMap来保存图片的路径和相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片对象所占用的空间，从而有效地避免了OOM的问题. 通过软引用实现Java对象的高速缓存:比如我们创建了一Person的类，如果每次需要查询一个人的信息,哪怕是几秒中之前刚刚查询过的，都要重新构建一个实例，这将引起大量Person对象的消耗,并且由于这些对象的生命周期相对较短,会引起多次GC影响性能。此时,通过软引用和 HashMap 的结合可以构建高速缓存,提供性能.java中==和**eqauls()的区别,equals()**和`hashcode的区别==是运算符,用于比较两个变量是否相等,而equals是Object类的方法,用于比较两个对象是否相等.默认Object类的equals方法是比较两个对象的地址,此时和==的结果一样.换句话说:基本类型比较用==,比较的是他们的值.默认下,对象用==比较时,比较的是内存地址,如果需要比较对象内容,需要重写equal方法equals()**和hashcode()的联系hashCode()是Object类的一个方法,返回一个哈希值.如果两个对象根据equal()方法比较相等,那么调用这两个对象中任意一个对象的hashCode()方法必须产生相同的哈希值.如果两个对象根据eqaul()方法比较不相等,那么产生的哈希值不一定相等(碰撞的情况下还是会相等的.) a.hashCode()有什么用?与a.equals(b)有什么关系hashCode() 方法是相应对象整型的 hash 值。它常用于基于 hash 的集合类，如 Hashtable、HashMap、LinkedHashMap等等。它与 equals() 方法关系特别紧密。根据 Java 规范，使用 equal() 方法来判断两个相等的对象，必须具有相同的 hashcode。将对象放入到集合中时,首先判断要放入对象的hashcode是否已经在集合中存在,不存在则直接放入集合.如果hashcode相等,然后通过equal()方法判断要放入对象与集合中的任意对象是否相等:如果equal()判断不相等,直接将该元素放入集合中,否则不放入. 有没有可能两个不相等的对象有相同的hashcode有可能，两个不相等的对象可能会有相同的 hashcode 值，这就是为什么在 hashmap 中会有冲突。如果两个对象相等，必须有相同的hashcode 值，反之不成立. 可以在hashcode中使用随机数字吗?不行，因为同一对象的 hashcode 值必须是相同的 a==b与a.equals(b)有什么区别如果a 和b 都是对象，则 a==b 是比较两个对象的引用，只有当 a 和 b 指向的是堆中的同一个对象才会返回 true，而 a.equals(b) 是进行逻辑比较，所以通常需要重写该方法来提供逻辑一致性的比较。例如，String 类重写 equals() 方法，所以可以用于两个不同对象，但是包含的字母相同的比较。 3*0.1==0.3**返回值是什么false，因为有些浮点数不能完全精确的表示出来。a=a+b与a+=b有什么区别吗?+=操作符会进行隐式自动类型转换,此处a+=b隐式的将加操作的结果类型强制转换为持有结果的类型,而a=a+b则不会自动进行类型转换.如：byte a = 127;byte b = 127;b = a + b; // error : cannot convert from int to byteb += a; // ok（译者注：这个地方应该表述的有误，其实无论 a+b 的值为多少，编译器都会报错，因为 a+b 操作会将 a、b 提升为 int 类型，所以将 int 类型赋值给 byte 就会编译出错）short s1= 1; s1 = s1 + 1; 该段代码是否有错,有的话怎么改？有错误,short类型在进行运算时会自动提升为int类型,也就是说s1+1的运算结果是int类型.short s1= 1; s1 += 1; 该段代码是否有错,有的话怎么改？+=操作符会自动对右边的表达式结果强转匹配左边的数据类型,所以没错.&amp; 和 &amp;&amp;的区别首先记住&amp;是位操作,而&amp;&amp;是逻辑运算符.另外需要记住逻辑运算符具有短路特性,而&amp;不具备短路特性.public class Test{static String name; public static void main(String[] args){ if(name!=null&amp;userName.equals(&quot;&quot;)){ System.out.println(&quot;ok&quot;); }else{ System.out.println(&quot;erro&quot;); } }} 以上代码将会抛出空指针异常.一个.java文件内部可以有类?(非内部类)只能有一个public公共类,但是可以有多个default修饰的类.如何正确的退出多层嵌套循环. 使用标号和break; 通过在外层循环中添加标识符内部类的作用内部类可以有多个实例,每个实例都有自己的状态信息,并且与其他外围对象的信息相互独立.在单个外围类当中,可以让多个内部类以不同的方式实现同一接口,或者继承同一个类.创建内部类对象的时刻不依赖于外部类对象的创建.内部类并没有令人疑惑的”is-a”关系,它就像是一个独立的实体.内部类提供了更好的封装,除了该外围类,其他类都不能访问final,finalize和finally的不同之处final 是一个修饰符，可以修饰变量、方法和类。如果 final 修饰变量，意味着该变量的值在初始化后不能被改变。finalize 方法是在对象被回收之前调用的方法，给对象自己最后一个复活的机会，但是什么时候调用 finalize 没有保证。finally 是一个关键字，与 try 和 catch 一起用于异常的处理。finally 块一定会被执行，无论在 try 块中是否有发生异常。clone()是哪个类的方法?java.lang.Cloneable 是一个标示性接口，不包含任何方法，clone 方法在 object 类中定义。并且需要知道 clone() 方法是一个本地方法，这意味着它是由 c 或 c++ 或 其他本地语言实现的。深拷贝和浅拷贝的区别是什么?浅拷贝：被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。换言之，浅拷贝仅仅复制所考虑的对象，而不复制它所引用的对象。深拷贝：被复制对象的所有变量都含有与原来的对象相同的值，而那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。换言之，深拷贝把要复制的对象所引用的对象都复制了一遍。static都有哪些用法?几乎所有的人都知道static关键字这两个基本的用法:静态变量和静态方法.也就是被static所修饰的变量/方法都属于类的静态资源,类实例所共享.除了静态变量和静态方法之外,static也用于静态块,多用于初始化操作:public calss PreCache{static{*//执行相关操作* }} 此外static也多用于修饰内部类,此时称之为静态内部类.最后一种用法就是静态导包,即import static.import static是在JDK 1.5之后引入的新特性,可以用来指定导入某个类中的静态资源,并且不需要使用类名.资源名,可以直接使用资源名,比如:import static java.lang.Math.*; public class Test{ public static void main(String[] args){ //System.out.println(Math.sin(20));传统做法 System.out.println(sin(20)); }} final有哪些用法final也是很多面试喜欢问的地方,能回答下以下三点就不错了:1.被final修饰的类不可以被继承2.被final修饰的方法不可以被重写3.被final修饰的变量不可以被改变.如果修饰引用,那么表示引用不可变,引用指向的内容可变.4.被final修饰的方法,JVM会尝试将其内联,以提高运行效率5.被final修饰的常量,在编译阶段会存入常量池中.回答出编译器对final域要遵守的两个重排序规则更好:1.在构造函数内对一个final域的写入,与随后把这个被构造对象的引用赋值给一个引用变量,这两个操作之间不能重排序.2.初次读一个包含final域的对象的引用,与随后初次读这个final域,这两个操作之间不能重排序. 数据类型相关java中int char,long各占多少字节? 类型 位数 字节数 short 2 16 int 4 32 long 8 64 float 4 32 double 8 64 char 2 16 64位的JVM当中,int的长度是多少?Java 中，int 类型变量的长度是一个固定值，与平台无关，都是 32 位。意思就是说，在 32 位 和 64 位 的Java 虚拟机中，int 类型的长度是相同的。int和Integer的区别Integer是int的包装类型,在拆箱和装箱中,二者自动转换.int是基本类型，直接存数值，而integer是对象，用一个引用指向这个对象.int 和Integer谁占用的内存更多?Integer 对象会占用更多的内存。Integer是一个对象，需要存储对象的元数据。但是 int 是一个原始类型的数据，所以占用的空间更少。String,StringBuffer和StringBuilder区别String是字符串常量,final修饰;StringBuffer字符串变量(线程安全);StringBuilder 字符串变量(线程不安全).String和StringBufferString和StringBuffer主要区别是性能:String是不可变对象,每次对String类型进行操作都等同于产生了一个新的String对象,然后指向新的String对象.所以尽量不在对String进行大量的拼接操作,否则会产生很多临时对象,导致GC开始工作,影响系统性能.StringBuffer是对对象本身操作,而不是产生新的对象,因此在有大量拼接的情况下,我们建议使用StringBuffer.但是需要注意现在JVM会对String拼接做一定的优化:String s=“This is only ”+”simple”+”test”会被虚拟机直接优化成String s=“This is only simple test”,此时就不存在拼接过程.StringBuffer和StringBuilderStringBuffer是线程安全的可变字符串,其内部实现是可变数组.StringBuilder是jdk 1.5新增的,其功能和StringBuffer类似,但是非线程安全.因此,在没有多线程问题的前提下,使用StringBuilder会取得更好的性能.什么是编译器常量?使用它有什么风险?公共静态不可变（public static final ）变量也就是我们所说的编译期常量，这里的 public 可选的。实际上这些变量在编译时会被替换掉，因为编译器知道这些变量的值，并且知道这些变量在运行时不能改变。这种方式存在的一个问题是你使用了一个内部的或第三方库中的公有编译时常量，但是这个值后面被其他人改变了，但是你的客户端仍然在使用老的值，甚至你已经部署了一个新的jar。为了避免这种情况，当你在更新依赖 JAR 文件时，确保重新编译你的程序。java当中使用什么类型表示价格比较好?如果不是特别关心内存和性能的话，使用BigDecimal，否则使用预定义精度的 double 类型。如何将byte转为String可以使用 String 接收 byte[] 参数的构造器来进行转换，需要注意的点是要使用的正确的编码，否则会使用平台默认编码，这个编码可能跟原来的编码相同，也可能不同。可以将int强转为byte类型么?会产生什么问题?我们可以做强制转换，但是Java中int是32位的而byte是8 位的，所以,如果强制转化int类型的高24位将会被丢弃，byte 类型的范围是从-128到128 关于垃圾回收你知道哪些垃圾回收算法?垃圾回收从理论上非常容易理解,具体的方法有以下几种: 标记-清除 标记-复制 标记-整理 分代回收 更详细的内容参见深入理解垃圾回收算法：http://blog.csdn.net/dd864140130/article/details/50084471如何判断一个对象是否应该被回收这就是所谓的对象存活性判断,常用的方法有两种:1.引用计数法;2:对象可达性分析.由于引用计数法存在互相引用导致无法进行GC的问题,所以目前JVM虚拟机多使用对象可达性分析算法.简单的解释一下垃圾回收Java 垃圾回收机制最基本的做法是分代回收。内存中的区域被划分成不同的世代，对象根据其存活的时间被保存在对应世代的区域中。一般的实现是划分成3个世代：年轻、年老和永久。内存的分配是发生在年轻世代中的。当一个对象存活时间足够长的时候，它就会被复制到年老世代中。对于不同的世代可以使用不同的垃圾回收算法。进行世代划分的出发点是对应用中对象存活时间进行研究之后得出的统计规律。一般来说，一个应用中的大部分对象的存活时间都很短。比如局部变量的存活时间就只在方法的执行过程中。基于这一点，对于年轻世代的垃圾回收算法就可以很有针对性.调用System.gc()会发生什么?通知GC开始工作,但是GC真正开始的时间不确定. 进程,线程相关说说进程,线程,协程之间的区别简而言之,进程是程序运行和资源分配的基本单位,一个程序至少有一个进程,一个进程至少有一个线程.进程在执行过程中拥有独立的内存单元,而多个线程共享内存资源,减少切换次数,从而效率更高.线程是进程的一个实体,是cpu调度和分派的基本单位,是比程序更小的能独立运行的基本单位.同一进程中的多个线程之间可以并发执行.你了解守护线程吗?它和非守护线程有什么区别程序运行完毕,jvm会等待非守护线程完成后关闭,但是jvm不会等待守护线程.守护线程最典型的例子就是GC线程什么是多线程上下文切换多线程的上下文切换是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。创建两种线程的方式?他们有什么区别?通过实现java.lang.Runnable或者通过扩展java.lang.Thread类.相比扩展Thread,实现Runnable接口可能更优.原因有二: Java不支持多继承.因此扩展Thread类就代表这个子类不能扩展其他类.而实现Runnable接口的类还可能扩展另一个类. 类可能只要求可执行即可,因此继承整个Thread类的开销过大.Thread类中的start()和run()方法有什么区别?start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程。怎么检测一个线程是否持有对象监视器Thread类提供了一个holdsLock(Object obj)方法，当且仅当对象obj的监视器被某条线程持有的时候才会返回true，注意这是一个static方法，这意味着”某条线程”指的是当前线程。Runnable和Callable的区别Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。这其实是很有用的一个特性，因为多线程相比单线程更难、更复杂的一个重要原因就是因为多线程充满着未知性，某条线程是否执行了？某条线程执行了多久？某条线程执行的时候我们期望的数据是否已经赋值完毕？无法得知，我们能做的只是等待这条多线程的任务执行完毕而已。而Callable+Future/FutureTask却可以方便获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务什么导致线程阻塞阻塞指的是暂停一个线程的执行以等待某个条件发生（如某资源就绪），学过操作系统的同学对它一定已经很熟悉了。Java 提供了大量方法来支持阻塞，下面让我们逐一分析。 方法 说明 sleep() sleep() 允许 指定以毫秒为单位的一段时间作为参数，它使得线程在指定的时间内进入阻塞状态，不能得到CPU 时间，指定的时间一过，线程重新进入可执行状态。 典型地，sleep() 被用在等待某个资源就绪的情形：测试发现条件不满足后，让线程阻塞一段时间后重新测试，直到条件满足为止 suspend() 和 resume() 两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的resume() 被调用，才能使得线程重新进入可执行状态。典型地，suspend() 和 resume() 被用在等待另一个线程产生的结果的情形：测试发现结果还没有产生后，让线程阻塞，另一个线程产生了结果后，调用 resume() 使其恢复。 yield() yield() 使当前线程放弃当前已经分得的CPU 时间，但不使当前线程阻塞，即线程仍处于可执行状态，随时可能再次分得 CPU 时间。调用 yield() 的效果等价于调度程序认为该线程已执行了足够的时间从而转到另一个线程 wait() 和 notify() 两个方法配套使用，wait() 使得线程进入阻塞状态，它有两种形式，一种允许 指定以毫秒为单位的一段时间作为参数，另一种没有参数，前者当对应的 notify() 被调用或者超出指定时间时线程重新进入可执行状态，后者则必须对应的 notify() 被调用. wait(),notify()和suspend(),resume()之间的区别初看起来它们与 suspend() 和 resume() 方法对没有什么分别，但是事实上它们是截然不同的。区别的核心在于，前面叙述的所有方法，阻塞时都不会释放占用的锁（如果占用了的话），而这一对方法则相反。上述的核心区别导致了一系列的细节上的区别。首先，前面叙述的所有方法都隶属于 Thread 类，但是这一对却直接隶属于 Object 类，也就是说，所有对象都拥有这一对方法。初看起来这十分不可思议，但是实际上却是很自然的，因为这一对方法阻塞时要释放占用的锁，而锁是任何对象都具有的，调用任意对象的 wait() 方法导致线程阻塞，并且该对象上的锁被释放。而调用 任意对象的notify()方法则导致从调用该对象的 wait() 方法而阻塞的线程中随机选择的一个解除阻塞（但要等到获得锁后才真正可执行）。其次，前面叙述的所有方法都可在任何位置调用，但是这一对方法却必须在 synchronized 方法或块中调用，理由也很简单，只有在synchronized 方法或块中当前线程才占有锁，才有锁可以释放。同样的道理，调用这一对方法的对象上的锁必须为当前线程所拥有，这样才有锁可以释放。因此，这一对方法调用必须放置在这样的 synchronized 方法或块中，该方法或块的上锁对象就是调用这一对方法的对象。若不满足这一条件，则程序虽然仍能编译，但在运行时会出现IllegalMonitorStateException 异常。wait() 和 notify() 方法的上述特性决定了它们经常和synchronized关键字一起使用，将它们和操作系统进程间通信机制作一个比较就会发现它们的相似性：synchronized方法或块提供了类似于操作系统原语的功能，它们的执行不会受到多线程机制的干扰，而这一对方法则相当于 block 和wakeup 原语（这一对方法均声明为 synchronized）。它们的结合使得我们可以实现操作系统上一系列精妙的进程间通信的算法（如信号量算法），并用于解决各种复杂的线程间通信问题。关于 wait() 和 notify() 方法最后再说明两点：第一：调用 notify() 方法导致解除阻塞的线程是从因调用该对象的 wait() 方法而阻塞的线程中随机选取的，我们无法预料哪一个线程将会被选择，所以编程时要特别小心，避免因这种不确定性而产生问题。第二：除了 notify()，还有一个方法 notifyAll() 也可起到类似作用，唯一的区别在于，调用 notifyAll() 方法将把因调用该对象的 wait() 方法而阻塞的所有线程一次性全部解除阻塞。当然，只有获得锁的那一个线程才能进入可执行状态。谈到阻塞，就不能不谈一谈死锁，略一分析就能发现，suspend() 方法和不指定超时期限的 wait() 方法的调用都可能产生死锁。遗憾的是，Java 并不在语言级别上支持死锁的避免，我们在编程中必须小心地避免死锁。以上我们对 Java 中实现线程阻塞的各种方法作了一番分析，我们重点分析了 wait() 和 notify() 方法，因为它们的功能最强大，使用也最灵活，但是这也导致了它们的效率较低，较容易出错。实际使用中我们应该灵活使用各种方法，以便更好地达到我们的目的。产生死锁的条件1.互斥条件：一个资源每次只能被一个进程使用。2.请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。3.不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。4.循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。为什么wait()方法和notify()/notifyAll()方法要在同步块中被调用这是JDK强制的，wait()方法和notify()/notifyAll()方法在调用前都必须先获得对象的锁wait()方法和notify()/notifyAll()方法在放弃对象监视器时有什么区别wait()方法和notify()/notifyAll()方法在放弃对象监视器的时候的区别在于：wait()方法立即释放对象监视器，notify()/notifyAll()方法则会等待线程剩余代码执行完毕才会放弃对象监视器。wait()与sleep()的区别关于这两者已经在上面进行详细的说明,这里就做个概括好了:· sleep()来自Thread类，和wait()来自Object类.调用sleep()方法的过程中，线程不会释放对象锁。而 调用 wait 方法线程会释放对象锁· sleep()睡眠后不出让系统资源，wait让其他线程可以占用CPU· sleep(milliseconds)需要指定一个睡眠时间，时间一到会自动唤醒.而wait()需要配合notify()或者notifyAll()使用为什么wait,nofity和nofityAll这些方法不放在Thread类当中一个很明显的原因是JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。怎么唤醒一个阻塞的线程如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。什么是多线程的上下文切换多线程的上下文切换是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。synchronized和ReentrantLock的区别synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上：（1）ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁（2）ReentrantLock可以获取各种锁的信息（3）ReentrantLock可以灵活地实现多路通知另外，二者的锁机制其实也是不一样的:ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word.FutureTask是什么这个其实前面有提到过，FutureTask表示一个异步运算的任务。FutureTask里面可以传入一个Callable的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。当然，由于FutureTask也是Runnable接口的实现类，所以FutureTask也可以放入线程池中。一个线程如果出现了运行时异常怎么办?如果这个异常没有被捕获的话，这个线程就停止执行了。另外重要的一点是：如果这个线程持有某个某个对象的监视器，那么这个对象监视器会被立即释放Java当中有哪几种锁 自旋锁: 自旋锁在JDK1.6之后就默认开启了。基于之前的观察，共享数据的锁定状态只会持续很短的时间，为了这一小段时间而去挂起和恢复线程有点浪费，所以这里就做了一个处理，让后面请求锁的那个线程在稍等一会，但是不放弃处理器的执行时间，看看持有锁的线程能否快速释放。为了让线程等待，所以需要让线程执行一个忙循环也就是自旋操作。在jdk6之后，引入了自适应的自旋锁，也就是等待的时间不再固定了，而是由上一次在同一个锁上的自旋时间及锁的拥有者状态来决定 偏向锁: 在JDK1.之后引入的一项锁优化，目的是消除数据在无竞争情况下的同步原语。进一步提升程序的运行性能。 偏向锁就是偏心的偏，意思是这个锁会偏向第一个获得他的线程，如果接下来的执行过程中，改锁没有被其他线程获取，则持有偏向锁的线程将永远不需要再进行同步。偏向锁可以提高带有同步但无竞争的程序性能，也就是说他并不一定总是对程序运行有利，如果程序中大多数的锁都是被多个不同的线程访问，那偏向模式就是多余的，在具体问题具体分析的前提下，可以考虑是否使用偏向锁。 轻量级锁: 为了减少获得锁和释放锁所带来的性能消耗，引入了“偏向锁”和“轻量级锁”，所以在Java SE1.6里锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁如何在两个线程间共享数据通过在线程之间共享对象就可以了，然后通过wait/notify/notifyAll、await/signal/signalAll进行唤起和等待，比方说阻塞队列BlockingQueue就是为线程之间共享数据而设计的如何正确的使用wait()?使用if还是while?wait() 方法应该在循环调用，因为当线程获取到 CPU 开始执行的时候，其他条件可能还没有满足，所以在处理前，循环检测条件是否满足会更好。下面是一段标准的使用 wait 和 notify 方法的代码：synchronized (obj) {while (condition does not hold) obj.wait(); // (Releases lock, and reacquires on wakeup) … // Perform action appropriate to condition} 什么是线程局部变量ThreadLocal线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。ThreadLoal的作用是什么?简单说ThreadLocal就是一种以空间换时间的做法在每个Thread里面维护了一个ThreadLocal.ThreadLocalMap把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了.生产者消费者模型的作用是什么?（1）通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率，这是生产者消费者模型最重要的作用（2）解耦，这是生产者消费者模型附带的作用，解耦意味着生产者和消费者之间的联系少，联系越少越可以独自发展而不需要收到相互的制约写一个生产者-消费者队列可以通过阻塞队列实现,也可以通过wait-notify来实现.使用阻塞队列来实现//消费者public class Producer implements Runnable{ private final BlockingQueue queue; public Producer(BlockingQueue q){ this.queue=q; } @Override public void run() { try { while (true){ Thread.sleep(1000);//模拟耗时 queue.put(produce()); } }catch (InterruptedException e){ } } private int produce() { int n=new Random().nextInt(10000); System.out.println(“Thread:” + Thread.currentThread().getId() + “ produce:” + n); return n; }}//消费者public class Consumer implements Runnable { private final BlockingQueue queue; public Consumer(BlockingQueue q){ this.queue=q; } @Override public void run() { while (true){ try { Thread.sleep(2000);//模拟耗时 consume(queue.take()); }catch (InterruptedException e){ } } } private void consume(Integer n) { System.out.println(“Thread:” + Thread.currentThread().getId() + “ consume:” + n); }}//测试public class Main { public static void main(String[] args) { BlockingQueue queue=new ArrayBlockingQueue(100); Producer p=new Producer(queue); Consumer c1=new Consumer(queue); Consumer c2=new Consumer(queue); new Thread(p).start(); new Thread(c1).start(); new Thread(c2).start(); }} 使用wait-notify来实现该种方式应该最经典,这里就不做说明了如果你提交任务时，线程池队列已满，这时会发生什么如果你使用的LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为LinkedBlockingQueue可以近乎认为是一个无穷大的队列，可以无限存放任务；如果你使用的是有界队列比方说ArrayBlockingQueue的话，任务首先会被添加到ArrayBlockingQueue中，ArrayBlockingQueue满了，则会使用拒绝策略RejectedExecutionHandler处理满了的任务，默认是AbortPolicy。为什么要使用线程池避免频繁地创建和销毁线程，达到线程对象的重用。另外，使用线程池还可以根据项目灵活地控制并发的数目。java中用到的线程调度算法是什么抢占式。一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。Thread.sleep(0)的作用是什么由于Java采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到CPU控制权的情况，为了让某些优先级比较低的线程也能获取到CPU控制权，可以使用Thread.sleep(0)手动触发一次操作系统分配时间片的操作，这也是平衡CPU控制权的一种操作。什么是CASCAS，全称为Compare and Swap，即比较-替换。假设有三个操作数：内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，才会将内存值修改为B并返回true，否则什么都不做并返回false。当然CAS一定要volatile变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值，否则旧的预期值A对某条线程来说，永远是一个不会变的值A，只要某次CAS操作失败，永远都不可能成功什么是乐观锁和悲观锁乐观锁：乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。悲观锁：悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。ConcurrentHashMap的并发度是什么?ConcurrentHashMap的并发度就是segment的大小，默认为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这也是ConcurrentHashMap对Hashtable的最大优势，任何情况下，Hashtable能同时有两条线程获取Hashtable中的数据吗？ConcurrentHashMap的工作原理ConcurrentHashMap在jdk 1.6和jdk 1.8实现原理是不同的.jdk 1.6:ConcurrentHashMap是线程安全的，但是与Hashtablea相比，实现线程安全的方式不同。Hashtable是通过对hash表结构进行锁定，是阻塞式的，当一个线程占有这个锁时，其他线程必须阻塞等待其释放锁。ConcurrentHashMap是采用分离锁的方式，它并没有对整个hash表进行锁定，而是局部锁定，也就是说当一个线程占有这个局部锁时，不影响其他线程对hash表其他地方的访问。具体实现:ConcurrentHashMap内部有一个Segmentjdk 1.8在jdk 8中，ConcurrentHashMap不再使用Segment分离锁，而是采用一种乐观锁CAS算法来实现同步问题，但其底层还是“数组+链表-&gt;红黑树”的实现。CyclicBarrier和CountDownLatch区别这两个类非常类似，都在java.util.concurrent下，都可以用来表示代码运行到某个点上，二者的区别在于：· CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值-1而已，该线程继续运行· CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务· CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了java中的++操作符线程安全么?不是线程安全的操作。它涉及到多个指令，如读取变量值，增加，然后存储回内存，这个过程可能会出现多个线程交差你有哪些多线程开发良好的实践? 给线程命名 最小化同步范围 优先使用volatile 尽可能使用更高层次的并发工具而非wait和notify()来实现线程通信,如BlockingQueue,Semeaphore 优先使用并发容器而非同步容器. 考虑使用线程池 关于volatile关键字可以创建Volatile数组吗?Java 中可以创建 volatile类型数组，不过只是一个指向数组的引用，而不是整个数组。如果改变引用指向的数组，将会受到volatile 的保护，但是如果多个线程同时改变数组的元素，volatile标示符就不能起到之前的保护作用了volatile能使得一个非原子操作变成原子操作吗?一个典型的例子是在类中有一个 long 类型的成员变量。如果你知道该成员变量会被多个线程访问，如计数器、价格等，你最好是将其设置为 volatile。为什么？因为 Java 中读取 long 类型变量不是原子的，需要分成两步，如果一个线程正在修改该 long 变量的值，另一个线程可能只能看到该值的一半（前 32 位）。但是对一个 volatile 型的 long 或 double 变量的读写是原子。一种实践是用 volatile 修饰 long 和 double 变量，使其能按原子类型来读写。double 和 long 都是64位宽，因此对这两种类型的读是分为两部分的，第一次读取第一个 32 位，然后再读剩下的 32 位，这个过程不是原子的，但 Java 中 volatile 型的 long 或 double 变量的读写是原子的。volatile 修复符的另一个作用是提供内存屏障（memory barrier），例如在分布式框架中的应用。简单的说，就是当你写一个 volatile 变量之前，Java 内存模型会插入一个写屏障（write barrier），读一个 volatile 变量之前，会插入一个读屏障（read barrier）。意思就是说，在你写一个 volatile 域时，能保证任何线程都能看到你写的值，同时，在写之前，也能保证任何数值的更新对所有线程是可见的，因为内存屏障会将其他所有写的值更新到缓存。volatile类型变量提供什么保证?volatile 主要有两方面的作用:1.避免指令重排2.可见性保证.例如，JVM 或者 JIT为了获得更好的性能会对语句重排序，但是 volatile 类型变量即使在没有同步块的情况下赋值也不会与其他语句重排序。 volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。某些情况下，volatile 还能提供原子性，如读 64 位数据类型，像 long 和 double 都不是原子的(低32位和高32位)，但 volatile 类型的 double 和 long 就是原子的. 关于集合Java中的集合及其继承关系关于集合的体系是每个人都应该烂熟于心的,尤其是对我们经常使用的List,Map的原理更该如此.这里我们看这张图即可:更多内容可见集合类总结：http://write.blog.csdn.net/postedit/40826423poll()方法和remove()方法区别?poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。LinkedHashMap和PriorityQueue的区别PriorityQueue 是一个优先级队列,保证最高或者最低优先级的的元素总是在队列头部，但是 LinkedHashMap 维持的顺序是元素插入的顺序。当遍历一个 PriorityQueue 时，没有任何顺序保证，但是 LinkedHashMap 课保证遍历顺序是元素插入的顺序。WeakHashMap与HashMap的区别是什么?WeakHashMap 的工作与正常的 HashMap 类似，但是使用弱引用作为 key，意思就是当 key 对象没有任何引用时，key/value 将会被回收。ArrayList和LinkedList的区别?最明显的区别是 ArrrayList底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构是双向循环链表，不支持随机访问。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。ArrayList和Array有什么区别? Array可以容纳基本类型和对象，而ArrayList只能容纳对象。 Array是指定大小的，而ArrayList大小是固定的ArrayList和HashMap默认大小?在 Java 7 中，ArrayList 的默认大小是 10 个元素，HashMap 的默认大小是16个元素（必须是2的幂）。这就是 Java 7 中 ArrayList 和 HashMap 类的代码片段private static final int DEFAULT_CAPACITY = 10; //from HashMap.java JDK 7static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16 Comparator和Comparable的区别?Comparable 接口用于定义对象的自然顺序，而 comparator 通常用于定义用户定制的顺序。Comparable 总是只有一个，但是可以有多个 comparator 来定义对象的顺序。如何实现集合排序?你可以使用有序集合，如 TreeSet 或 TreeMap，你也可以使用有顺序的的集合，如 list，然后通过 Collections.sort() 来排序。如何打印数组内容你可以使用 Arrays.toString() 和 Arrays.deepToString() 方法来打印数组。由于数组没有实现 toString() 方法，所以如果将数组传递给 System.out.println() 方法，将无法打印出数组的内容，但是 Arrays.toString() 可以打印每个元素。LinkedList的是单向链表还是双向?双向循环列表,具体实现自行查阅源码.TreeMap是实现原理采用红黑树实现,具体实现自行查阅源码.遍历ArrayList时如何正确移除一个元素该问题的关键在于面试者使用的是 ArrayList 的 remove() 还是 Iterator 的 remove()方法。这有一段示例代码，是使用正确的方式来实现在遍历的过程中移除元素，而不会出现 ConcurrentModificationException 异常的示例代码。什么是ArrayMap?它和HashMap有什么区别?ArrayMap是Android SDK中提供的,非Android开发者可以略过.ArrayMap是用两个数组来模拟map,更少的内存占用空间,更高的效率.具体参考这篇文章:ArrayMap VS HashMap：http://lvable.com/?p=217%5DHashMap的实现原理1 HashMap概述： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。2 HashMap的数据结构： 在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。当我们往Hashmap中put元素时,首先根据key的hashcode重新计算hash值,根绝hash值得到这个元素在数组中的位置(下标),如果该数组在该位置上已经存放了其他元素,那么在这个位置上的元素将以链表的形式存放,新加入的放在链头,最先加入的放入链尾.如果数组中该位置没有元素,就直接将该元素放到数组的该位置上.需要注意Jdk 1.8中对HashMap的实现做了优化,当链表中的节点数据超过八个之后,该链表会转为红黑树来提高查询效率,从原来的O(n)到O(logn)你了解Fail-Fast机制吗Fail-Fast即我们常说的快速失败,更多内容参看fail-fast机制：http://blog.csdn.net/chenssy/article/details/38151189Fail-fast和Fail-safe有什么区别Iterator的fail-fast属性与当前的集合共同起作用，因此它不会受到集合中任何改动的影响。Java.util包中的所有集合类都被设计为fail-&gt;fast的，而java.util.concurrent中的集合类都为fail-safe的。当检测到正在遍历的集合的结构被改变时，Fail-fast迭代器抛出ConcurrentModificationException，而fail-safe迭代器从不抛出ConcurrentModificationException。 关于日期SimpleDateFormat是线程安全的吗?非常不幸，DateFormat 的所有实现，包括 SimpleDateFormat 都不是线程安全的，因此你不应该在多线程序中使用，除非是在对外线程安全的环境中使用，如 将 SimpleDateFormat 限制在 ThreadLocal 中。如果你不这么做，在解析或者格式化日期的时候，可能会获取到一个不正确的结果。因此，从日期、时间处理的所有实践来说，我强力推荐 joda-time 库。如何格式化日期?Java 中，可以使用 SimpleDateFormat 类或者 joda-time 库来格式日期。DateFormat 类允许你使用多种流行的格式来格式化日期。参见答案中的示例代码，代码中演示了将日期格式化成不同的格式，如 dd-MM-yyyy 或 ddMMyyyy。 关于异常简单描述java异常体系相比没有人不了解异常体系,关于异常体系的更多信息可以见白话异常机制：http://blog.csdn.net/dd864140130/article/details/42504189什么是异常链详情直接参见上面的白话异常机制,不做解释了.throw和throws的区别throw用于主动抛出java.lang.Throwable 类的一个实例化对象，意思是说你可以通过关键字 throw 抛出一个 Error 或者 一个Exception，如：throw new IllegalArgumentException(“size must be multiple of 2″),而throws 的作用是作为方法声明和签名的一部分，方法被抛出相应的异常以便调用者能处理。Java 中，任何未处理的受检查异常强制在 throws 子句中声明。 关于序列化Java 中，Serializable 与 Externalizable 的区别Serializable 接口是一个序列化 Java 类的接口，以便于它们可以在网络上传输或者可以将它们的状态保存在磁盘上，是 JVM 内嵌的默认序列化方式，成本高、脆弱而且不安全。Externalizable 允许你控制整个序列化过程，指定特定的二进制格式，增加安全机制。 关于JVMJVM特性平台无关性.Java语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用模式Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。简单解释一下类加载器有关类加载器一般会问你四种类加载器的应用场景以及双亲委派模型,更多的内容参看深入理解JVM加载器：http://blog.csdn.net/dd864140130/article/details/49817357简述堆和栈的区别VM 中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。简述JVM内存分配 基本数据类型比变量和对象的引用都是在栈分配的 堆内存用来存放由new创建的对象和数组 类变量（static修饰的变量），程序在一加载的时候就在堆中为类变量分配内存，堆中的内存地址存放在栈中 实例变量：当你使用java关键字new的时候，系统在堆中开辟并不一定是连续的空间分配给变量，是根据零散的堆内存地址，通过哈希算法换算为一长串数字以表征这个变量在堆中的”物理位置”,实例变量的生命周期–当实例变量的引用丢失后，将被GC（垃圾回收器）列入可回收“名单”中，但并不是马上就释放堆中内存 局部变量: 由声明在某方法，或某代码段里（比如for循环），执行到它的时候在栈中开辟内存，当局部变量一但脱离作用域，内存立即释放 其他java当中采用的是大端还是小端?XML解析的几种方式和特点DOM,SAX,PULL三种解析方式:· DOM:消耗内存：先把xml文档都读到内存中，然后再用DOM API来访问树形结构，并获取数据。这个写起来很简单，但是很消耗内存。要是数据过大，手机不够牛逼，可能手机直接死机· SAX:解析效率高，占用内存少，基于事件驱动的：更加简单地说就是对文档进行顺序扫描，当扫描到文档(document)开始与结束、元素(element)开始与结束、文档(document)结束等地方时通知事件处理函数，由事件处理函数做相应动作，然后继续同样的扫描，直至文档结束。· PULL:与 SAX 类似，也是基于事件驱动，我们可以调用它的next（）方法，来获取下一个解析事件（就是开始文档，结束文档，开始标签，结束标签），当处于某个元素时可以调用XmlPullParser的getAttributte()方法来获取属性的值，也可调用它的nextText()获取本节点的值。JDK 1.7特性然 JDK 1.7 不像 JDK 5 和 8 一样的大版本，但是，还是有很多新的特性，如 try-with-resource 语句，这样你在使用流或者资源的时候，就不需要手动关闭，Java 会自动关闭。Fork-Join 池某种程度上实现 Java 版的 Map-reduce。允许 Switch 中有 String 变量和文本。菱形操作符(&lt;&gt;)用于类型推断，不再需要在变量声明的右边申明泛型，因此可以写出可读写更强、更简洁的代码JDK 1.8特性java 8 在 Java 历史上是一个开创新的版本，下面 JDK 8 中 5 个主要的特性：Lambda 表达式，允许像对象一样传递匿名函数Stream API，充分利用现代多核 CPU，可以写出很简洁的代码Date 与 Time API，最终，有一个稳定、简单的日期和时间库可供你使用扩展方法，现在，接口中可以有静态、默认方法。重复注解，现在你可以将相同的注解在同一类型上使用多次。Maven和ANT有什么区别?虽然两者都是构建工具，都用于创建 Java 应用，但是 Maven 做的事情更多，在基于“约定优于配置”的概念下，提供标准的Java 项目结构，同时能为应用自动管理依赖（应用中所依赖的 JAR 文件.JDBC最佳实践· 优先使用批量操作来插入和更新数据· 使用PreparedStatement来避免SQL漏洞· 使用数据连接池· 通过列名来获取结果集IO操作最佳实践· 使用有缓冲的IO类,不要单独读取字节或字符· 使用NIO和NIO 2或者AIO,而非BIO· 在finally中关闭流· 使用内存映射文件获取更快的IO 好的东西要和朋友一起分享，赶快将本文分享给你身边正在准备Java面试的朋友吧！ ●编号684，输入编号直达本文●输入m获取文章目录推荐↓↓↓Python编程更多推荐：《18个技术类微信公众号》涵盖：程序人生、算法与数据结构、黑客技术与网络安全、大数据技术、前端开发、Java、Python、Web开发、安卓开发、iOS开发、C/C++、.NET、Linux、数据库、运维等。阅读原文微信扫一扫关注该公众号","link":"/2019/04/29/java面试/"},{"title":"","text":"写博客的目的 记录一下学的知识 同样的错误不犯第二次 解决错误之后系统的理解为什么会出现错误 ##遗留问题： 文章页只显示文章和目录 首页文章显示预览 知识星球去掉","link":"/2020/01/08/写博客的目的/"},{"title":"README","text":"Goal于2019.04.22正式开始记录，坚持每天总结，暂时截至研究生考试结束 锻炼自己的能力 练习Markdown语法 每周做一次全面的总结 ​","link":"/2020/01/08/README/"}],"tags":[{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"词云图","slug":"词云图","link":"/tags/词云图/"},{"name":"环境搭建","slug":"环境搭建","link":"/tags/环境搭建/"},{"name":"小程序","slug":"小程序","link":"/tags/小程序/"},{"name":"WIn10","slug":"WIn10","link":"/tags/WIn10/"},{"name":"有道云","slug":"有道云","link":"/tags/有道云/"},{"name":"服务器","slug":"服务器","link":"/tags/服务器/"},{"name":"Google","slug":"Google","link":"/tags/Google/"},{"name":"数据库","slug":"数据库","link":"/tags/数据库/"},{"name":"面试","slug":"面试","link":"/tags/面试/"},{"name":"README","slug":"README","link":"/tags/README/"}],"categories":[{"name":"博客","slug":"博客","link":"/categories/博客/"},{"name":"Python数据分析","slug":"Python数据分析","link":"/categories/Python数据分析/"},{"name":"php","slug":"php","link":"/categories/php/"},{"name":"微信小程序","slug":"微信小程序","link":"/categories/微信小程序/"},{"name":"电脑问题","slug":"电脑问题","link":"/categories/电脑问题/"},{"name":"笔记整理","slug":"笔记整理","link":"/categories/笔记整理/"},{"name":"javaweb","slug":"javaweb","link":"/categories/javaweb/"},{"name":"书签","slug":"书签","link":"/categories/书签/"},{"name":"数据库相关知识","slug":"数据库相关知识","link":"/categories/数据库相关知识/"},{"name":"java","slug":"java","link":"/categories/java/"},{"name":"README","slug":"README","link":"/categories/README/"}]}